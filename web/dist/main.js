/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/sprintf-js/src/sprintf.js":
/*!************************************************!*\
  !*** ./node_modules/sprintf-js/src/sprintf.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (true) {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n\n\n//# sourceURL=webpack:///./node_modules/sprintf-js/src/sprintf.js?");

/***/ }),

/***/ "./src/CharacterDeviceImpl.ts":
/*!************************************!*\
  !*** ./src/CharacterDeviceImpl.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CharacterDeviceImpl = /** @class */ (function () {\n    function CharacterDeviceImpl(textarea) {\n        this.textarea = null;\n        this.textarea = textarea;\n    }\n    CharacterDeviceImpl.prototype.outMessage = function (s) {\n        this.print(s + \"\\n\");\n    };\n    CharacterDeviceImpl.prototype.outDebug = function (n) {\n        this.print(\"debug: \" + n + \"\\n\");\n    };\n    CharacterDeviceImpl.prototype.print = function (s) {\n        this.textarea.value += s;\n    };\n    return CharacterDeviceImpl;\n}());\nexports.default = CharacterDeviceImpl;\n\n\n//# sourceURL=webpack:///./src/CharacterDeviceImpl.ts?");

/***/ }),

/***/ "./src/GraphicDeviceImpl.ts":
/*!**********************************!*\
  !*** ./src/GraphicDeviceImpl.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint no-unused-vars: 0 */\nvar sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/sprintf-js/src/sprintf.js\");\nvar SCREEN_WIDTH = 100;\nvar SCREEN_HEIGHT = 100;\nvar SCALE_X = 4;\nvar SCALE_Y = 4;\nvar GraphicDeviceImpl = /** @class */ (function () {\n    function GraphicDeviceImpl(frontCanvas, backCanvas) {\n        this.frontCanvas = frontCanvas;\n        this.backCanvas = backCanvas;\n        var fctx = frontCanvas.getContext('2d');\n        if (fctx === null) {\n            throw new Error('frontContext is null');\n        }\n        this.frontContext = fctx;\n        var bctx = backCanvas.getContext('2d');\n        if (bctx === null) {\n            throw new Error('backContext is null');\n        }\n        this.backContext = bctx;\n    }\n    GraphicDeviceImpl.prototype.clear = function () {\n        this.backContext.fillStyle = '#000000';\n        this.backContext.fillRect(0, 0, this.backCanvas.width, this.backCanvas.height);\n        this.vsync();\n    };\n    GraphicDeviceImpl.prototype.write = function (addr, value) {\n        var x = addr % SCREEN_WIDTH;\n        var y = Math.floor(addr / SCREEN_WIDTH);\n        this.setPixel(x, y, value);\n    };\n    GraphicDeviceImpl.prototype.vsync = function () {\n        var image = this.backContext.getImageData(0, 0, this.backCanvas.width, this.backCanvas.height);\n        this.frontContext.putImageData(image, 0, 0);\n    };\n    GraphicDeviceImpl.prototype.setPixel = function (x, y, sunabaColor) {\n        this.backContext.fillStyle = this.convertColor(sunabaColor);\n        this.backContext.fillRect(x * SCALE_X, y * SCALE_Y, SCALE_X, SCALE_Y);\n    };\n    GraphicDeviceImpl.prototype.convertColor = function (sunabaColor) {\n        if (sunabaColor < 0) {\n            return '#000000';\n        }\n        if (sunabaColor > 999999) {\n            return '#FFFFFF';\n        }\n        var r = Math.floor(sunabaColor / 10000) % 100;\n        var g = Math.floor(sunabaColor / 100) % 100;\n        var b = (sunabaColor % 100);\n        r *= (255 / 99);\n        g *= (255 / 99);\n        b *= (255 / 99);\n        var color = \"#\" + sprintf_js_1.sprintf('%02x%02x%02x', r, g, b);\n        return color;\n    };\n    return GraphicDeviceImpl;\n}());\nexports.default = GraphicDeviceImpl;\n\n\n//# sourceURL=webpack:///./src/GraphicDeviceImpl.ts?");

/***/ }),

/***/ "./src/KeyboardDeviceImpl.ts":
/*!***********************************!*\
  !*** ./src/KeyboardDeviceImpl.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar KeyboardDeviceImpl = /** @class */ (function () {\n    function KeyboardDeviceImpl(window) {\n        var _this = this;\n        this.arrowLeftKeyDowned = false;\n        this.arrowUpKeyDowned = false;\n        this.arrowRightKeyDowned = false;\n        this.arrowDownKeyDowned = false;\n        this.spaceKeyDowned = false;\n        this.enterKeyDowned = false;\n        window.addEventListener('keydown', function (event) {\n            _this.setKeyDowned(event.keyCode, true);\n        });\n        window.addEventListener('keyup', function (event) {\n            _this.setKeyDowned(event.keyCode, false);\n        });\n    }\n    ;\n    ;\n    ;\n    ;\n    ;\n    KeyboardDeviceImpl.prototype.isArrowLeftDowned = function () {\n        return this.arrowLeftKeyDowned;\n    };\n    KeyboardDeviceImpl.prototype.isArrowUpKeyDowned = function () {\n        return this.arrowUpKeyDowned;\n    };\n    KeyboardDeviceImpl.prototype.isArrowDownDowned = function () {\n        return this.arrowDownKeyDowned;\n    };\n    KeyboardDeviceImpl.prototype.isArrowRightKeyDowned = function () {\n        return this.arrowRightKeyDowned;\n    };\n    KeyboardDeviceImpl.prototype.isSpaceKeyDowned = function () {\n        return this.spaceKeyDowned;\n    };\n    KeyboardDeviceImpl.prototype.isEnterKeyDowned = function () {\n        return this.enterKeyDowned;\n    };\n    KeyboardDeviceImpl.prototype.setKeyDowned = function (keyCode, downed) {\n        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Value_of_keyCode\n        switch (keyCode) {\n            case 13:\n                this.enterKeyDowned = downed;\n                break;\n            case 32:\n                this.spaceKeyDowned = downed;\n                break;\n            case 37:\n                this.arrowLeftKeyDowned = downed;\n                break;\n            case 38:\n                this.arrowUpKeyDowned = downed;\n                break;\n            case 39:\n                this.arrowRightKeyDowned = downed;\n                break;\n            case 40:\n                this.arrowDownKeyDowned = downed;\n                break;\n            default:\n                break;\n        }\n        // console.log(`${this.enterKeyDowned} ${this.spaceKeyDowned} ${this.arrowLeftKeyDowned} ${this.arrowUpKeyDowned} ${this.arrowRightKeyDowned} ${this.arrowDownKeyDowned}`);\n    };\n    return KeyboardDeviceImpl;\n}());\nexports.default = KeyboardDeviceImpl;\n\n\n//# sourceURL=webpack:///./src/KeyboardDeviceImpl.ts?");

/***/ }),

/***/ "./src/MouseDeviceImpl.ts":
/*!********************************!*\
  !*** ./src/MouseDeviceImpl.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MouseDeviceImpl = /** @class */ (function () {\n    /* eslint no-bitwise: 0 */\n    function MouseDeviceImpl(el) {\n        var _this = this;\n        this.posX = 0;\n        this.posY = 0;\n        this.leftDowned = false;\n        this.rightDowned = false;\n        var LEFT_MASK = 1;\n        var RIGHT_MASK = 2;\n        el.addEventListener('mousemove', function (event) {\n            _this.posX = Math.floor(event.offsetX / 4);\n            _this.posY = Math.floor(event.offsetY / 4);\n        });\n        el.addEventListener('mousedown', function (event) {\n            _this.posX = Math.floor(event.offsetX / 4);\n            _this.posY = Math.floor(event.offsetY / 4);\n            _this.leftDowned = (event.buttons & LEFT_MASK) !== 0;\n            _this.rightDowned = (event.buttons & RIGHT_MASK) !== 0;\n        });\n        el.addEventListener('mouseup', function (event) {\n            _this.posX = Math.floor(event.offsetX / 4);\n            _this.posY = Math.floor(event.offsetY / 4);\n            _this.leftDowned = (event.buttons & LEFT_MASK) !== 0;\n            _this.rightDowned = (event.buttons & RIGHT_MASK) !== 0;\n        });\n    }\n    MouseDeviceImpl.prototype.getPosX = function () {\n        return this.posX;\n    };\n    MouseDeviceImpl.prototype.getPosY = function () {\n        return this.posY;\n    };\n    MouseDeviceImpl.prototype.isLeftButtonDowned = function () {\n        return this.leftDowned;\n    };\n    MouseDeviceImpl.prototype.isRightButtonDowned = function () {\n        return this.rightDowned;\n    };\n    return MouseDeviceImpl;\n}());\nexports.default = MouseDeviceImpl;\n\n\n//# sourceURL=webpack:///./src/MouseDeviceImpl.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Machine_1 = __importDefault(__webpack_require__(/*! ./sunaba/Machine */ \"./src/sunaba/Machine.ts\"));\nvar Compiler_1 = __importDefault(__webpack_require__(/*! ./sunaba/Compiler */ \"./src/sunaba/Compiler.ts\"));\nvar MouseDeviceImpl_1 = __importDefault(__webpack_require__(/*! ./MouseDeviceImpl */ \"./src/MouseDeviceImpl.ts\"));\nvar KeyboardDeviceImpl_1 = __importDefault(__webpack_require__(/*! ./KeyboardDeviceImpl */ \"./src/KeyboardDeviceImpl.ts\"));\nvar CharacterDeviceImpl_1 = __importDefault(__webpack_require__(/*! ./CharacterDeviceImpl */ \"./src/CharacterDeviceImpl.ts\"));\nvar GraphicDeviceImpl_1 = __importDefault(__webpack_require__(/*! ./GraphicDeviceImpl */ \"./src/GraphicDeviceImpl.ts\"));\nwindow.addEventListener('load', function () {\n    var frontCanvas = document.getElementById('screen2');\n    var backCanvas = document.getElementById('screen');\n    var machine = new Machine_1.default();\n    var mouseDevice = new MouseDeviceImpl_1.default(frontCanvas);\n    machine.setMouseDevice(mouseDevice);\n    var keyboardDevice = new KeyboardDeviceImpl_1.default(window);\n    machine.setKeyboardDevice(keyboardDevice);\n    var characterDevice = new CharacterDeviceImpl_1.default(document.getElementById('message'));\n    machine.setCharacterDevice(characterDevice);\n    var graphicDevice = new GraphicDeviceImpl_1.default(frontCanvas, backCanvas);\n    machine.setGraphicDevice(graphicDevice);\n    document.getElementById('runButton').addEventListener('click', function () {\n        var code = document.getElementById('code').value;\n        var compiler = new Compiler_1.default();\n        var results = compiler.compile(code);\n        if (results.errorMessage.length > 0) {\n            characterDevice.outMessage(results.errorMessage + \"\\n\");\n            return;\n        }\n        graphicDevice.clear();\n        machine.loadProgram(results.commands);\n    });\n    document.getElementById('stopButton').addEventListener('click', function () {\n        machine.stop();\n    });\n    document.getElementById('clearButton').addEventListener('click', function () {\n        document.getElementById('message').value = '';\n    });\n    // TODO: UIスライダーで調整できるようにしたい\n    var INTERVAL_MILLSECONDS = 33; // 16:速すぎ、33:まだ速い\n    var MAX_STEP_COUNT_PER_FRAME = 1000;\n    window.setInterval(function () {\n        machine.runSingleFrame(INTERVAL_MILLSECONDS - 2, MAX_STEP_COUNT_PER_FRAME);\n    }, INTERVAL_MILLSECONDS);\n});\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/sunaba/AsmCommand.ts":
/*!**********************************!*\
  !*** ./src/sunaba/AsmCommand.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AsmCommand = /** @class */ (function () {\n    function AsmCommand(label, name, imm, comment) {\n        if (label === void 0) { label = ''; }\n        if (name === void 0) { name = ''; }\n        if (imm === void 0) { imm = 0; }\n        if (comment === void 0) { comment = ''; }\n        this.imm = 0;\n        this.comment = '';\n        this.label = label;\n        this.name = name;\n        this.imm = imm;\n        this.comment = comment;\n    }\n    return AsmCommand;\n}());\nexports.default = AsmCommand;\n\n\n//# sourceURL=webpack:///./src/sunaba/AsmCommand.ts?");

/***/ }),

/***/ "./src/sunaba/Assembler.ts":
/*!*********************************!*\
  !*** ./src/sunaba/Assembler.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint\n   no-unused-vars: 0,\n   class-methods-use-this: 0\n*/\nvar VmCommand_1 = __importDefault(__webpack_require__(/*! ./VmCommand */ \"./src/sunaba/VmCommand.ts\"));\n// E300\nvar Assembler = /** @class */ (function () {\n    function Assembler() {\n    }\n    Assembler.prototype.assemble = function (asmCmds) {\n        var labelAddressMap = this.collectLabel(asmCmds);\n        var vmCmds = this.resolveLabelAddress(asmCmds, labelAddressMap);\n        return vmCmds;\n    };\n    // E300\n    Assembler.prototype.collectLabel = function (asmCmds) {\n        var labelAddressMap = {};\n        for (var i = 0; i < asmCmds.length; i += 1) {\n            var cmd = asmCmds[i];\n            if (cmd.label) {\n                if (cmd.label in labelAddressMap) {\n                    throw new Error(\"E300: label duplicated: \" + cmd.label);\n                }\n                labelAddressMap[cmd.label] = i;\n            }\n        }\n        return labelAddressMap;\n    };\n    Assembler.prototype.resolveLabelAddress = function (asmCmds, labelAddressMap) {\n        var outCmds = [];\n        for (var i = 0; i < asmCmds.length; i += 1) {\n            var asmCmd = asmCmds[i];\n            var vmcmd_imm = 0;\n            if (typeof asmCmd.imm === 'string') {\n                if (asmCmd.imm === '') {\n                    vmcmd_imm = 0;\n                }\n                else if (asmCmd.imm in labelAddressMap) {\n                    vmcmd_imm = labelAddressMap[asmCmd.imm];\n                }\n                else {\n                    throw new Error(\"E302: imm not resolved': \" + asmCmd.name + \" \" + asmCmd.imm + \" \" + asmCmd.comment);\n                }\n            }\n            else {\n                vmcmd_imm = asmCmd.imm;\n            }\n            var vmcmd = new VmCommand_1.default(asmCmd.label, asmCmd.name, vmcmd_imm, asmCmd.comment);\n            outCmds.push(vmcmd);\n        }\n        return outCmds;\n    };\n    return Assembler;\n}());\nexports.default = Assembler;\n\n\n//# sourceURL=webpack:///./src/sunaba/Assembler.ts?");

/***/ }),

/***/ "./src/sunaba/CharacterDevice.ts":
/*!***************************************!*\
  !*** ./src/sunaba/CharacterDevice.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar NullCharacterDevice = /** @class */ (function () {\n    function NullCharacterDevice() {\n    }\n    /* eslint no-console: 0 */\n    NullCharacterDevice.prototype.outMessage = function (s) {\n        console.log(s);\n    };\n    NullCharacterDevice.prototype.outDebug = function (n) {\n        console.log(n);\n    };\n    return NullCharacterDevice;\n}());\nexports.NullCharacterDevice = NullCharacterDevice;\n\n\n//# sourceURL=webpack:///./src/sunaba/CharacterDevice.ts?");

/***/ }),

/***/ "./src/sunaba/CodeGenerator.ts":
/*!*************************************!*\
  !*** ./src/sunaba/CodeGenerator.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__filename) {\n/* eslint\n    no-unused-vars: 0\n*/\n// MEMO: no-unused-vars: 0  4:8  error  'Node' is defined but never used  no-unused-vars\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HLib_1 = __importDefault(__webpack_require__(/*! ./HLib */ \"./src/sunaba/HLib.ts\"));\nvar FunctionInfo_1 = __importDefault(__webpack_require__(/*! ./FunctionInfo */ \"./src/sunaba/FunctionInfo.ts\"));\nvar FunctionGenerator_1 = __importDefault(__webpack_require__(/*! ./FunctionGenerator */ \"./src/sunaba/FunctionGenerator.ts\"));\nvar NodeType_1 = __webpack_require__(/*! ./NodeType */ \"./src/sunaba/NodeType.ts\");\nvar AsmCommand_1 = __importDefault(__webpack_require__(/*! ./AsmCommand */ \"./src/sunaba/AsmCommand.ts\"));\nvar CodeGenerator = /** @class */ (function () {\n    function CodeGenerator() {\n        this.mFunctionMap = {};\n        this.cmds = [];\n    }\n    CodeGenerator.prototype.addCommand = function (name, imm, comment) {\n        if (imm === void 0) { imm = 0; }\n        if (comment === void 0) { comment = ''; }\n        var cmd = new AsmCommand_1.default('', name, imm, comment);\n        this.cmds.push(cmd);\n    };\n    CodeGenerator.prototype.addLabel = function (label, comment) {\n        if (comment === void 0) { comment = ''; }\n        var cmd = new AsmCommand_1.default(label, '', 0, comment);\n        this.cmds.push(cmd);\n    };\n    CodeGenerator.prototype.mergeCommands = function (cmds) {\n        var _this = this;\n        cmds.forEach(function (item) {\n            _this.cmds.push(item);\n        });\n    };\n    CodeGenerator.prototype.getCommands = function () {\n        return this.cmds;\n    };\n    CodeGenerator.prototype.generateProgram = function (node) {\n        HLib_1.default.assert(node.type === NodeType_1.NodeType.NODE_PROGRAM, __filename + \":34\");\n        this.addCommand('pop', -1, '#$mainの戻り値領域');\n        this.addCommand('call', 'func_!main'); // main()呼び出し 160413: add等のアセンブラ命令と同名の関数があった時にラベルを命令と間違えて誤作動する問題の緊急回避\n        this.addCommand('j', '!end', '#プログラム終了点へジャンプ'); // プログラム終了点へジャンプ\n        // $mainの情報を足しておく\n        var mainFuncInfo = new FunctionInfo_1.default();\n        this.mFunctionMap['!main'] = mainFuncInfo;\n        // 関数情報収集。関数コールを探しだして、見つけ次第、引数、出力、名前についての情報を収集してmapに格納\n        {\n            var child = node.child;\n            while (child) {\n                if (child.type === NodeType_1.NodeType.NODE_FUNCTION_DEFINITION) {\n                    if (!this.collectFunctionDefinitionInformation(child)) { // main以外\n                        return false;\n                    }\n                }\n                child = child.brother;\n            }\n        }\n        // 関数コールを探しだして、見つけ次第コード生成\n        {\n            var child = node.child;\n            while (child) {\n                if (child.type === NodeType_1.NodeType.NODE_FUNCTION_DEFINITION) {\n                    if (!this.generateFunctionDefinition(child)) { // main以外\n                        return false;\n                    }\n                }\n                else if (child.isOutputValueSubstitution()) { // なければ出力があるか調べる\n                    mainFuncInfo.setHasOutputValue(); // 戻り値があるのでフラグを立てる。\n                }\n                child = child.brother;\n            }\n        }\n        // あとはmain\n        if (!this.generateFunctionDefinition(node)) {\n            return false;\n        }\n        // 最後にプログラム終了ラベル\n        this.addLabel('!end');\n        this.addCommand('pop', 1, '#!mainの戻り値を破棄。最終命令。なくてもいいが。');\n        return true;\n    };\n    CodeGenerator.prototype.collectFunctionDefinitionInformation = function (node) {\n        var argCount = 0; // 引数の数\n        // まず、関数マップに項目を足す\n        if (node.token === null) {\n            HLib_1.default.assert(false, __filename + \":84\");\n            return false;\n        }\n        var funcName = node.token.string;\n        // 関数重複チェック\n        if (this.mFunctionMap[funcName] !== undefined) {\n            throw new Error(\"\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\" + funcName + \"\\u306F\\u3082\\u3046\\u4F5C\\u3089\\u308C\\u3066\\u3044\\u308B\\u3002\");\n        }\n        var funcInfo = new FunctionInfo_1.default();\n        this.mFunctionMap[funcName] = funcInfo;\n        var child = node.child;\n        // 引数の処理\n        // まず数を数える\n        // argが後ろに残ってるとバグ源になるので閉じ込める\n        var arg = child; // childは後で必要なので、コピーを操作\n        while (arg) {\n            if (arg.type !== NodeType_1.NodeType.NODE_VARIABLE) {\n                break;\n            }\n            argCount += 1;\n            arg = arg.brother;\n        }\n        funcInfo.setArgCount(argCount);\n        // 出力値があるか調べる\n        while (child) {\n            if (child.isOutputValueSubstitution()) {\n                funcInfo.setHasOutputValue(); // 戻り値があるのでフラグを立てる。\n            }\n            child = child.brother;\n        }\n        return true;\n    };\n    CodeGenerator.prototype.generateFunctionDefinition = function (node) {\n        // まず、関数マップに項目を足す\n        var funcName;\n        if (node.token) {\n            funcName = node.token.string;\n        }\n        else {\n            funcName = '!main';\n        }\n        // 関数重複チェック\n        HLib_1.default.assert(this.mFunctionMap[funcName] !== undefined, __filename + \":131\"); // 絶対ある\n        var functionGenerator = new FunctionGenerator_1.default(this);\n        functionGenerator.process(node, funcName);\n        var cmds = functionGenerator.getCommands();\n        this.mergeCommands(cmds);\n        return true;\n    };\n    return CodeGenerator;\n}());\nexports.default = CodeGenerator;\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/index.js\"))\n\n//# sourceURL=webpack:///./src/sunaba/CodeGenerator.ts?");

/***/ }),

/***/ "./src/sunaba/Compiler.ts":
/*!********************************!*\
  !*** ./src/sunaba/Compiler.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint\n    no-unused-vars: 0,\n    no-restricted-globals: 0,\n    no-irregular-whitespace: 0\n*/\nvar Sunaba_1 = __importDefault(__webpack_require__(/*! ./Sunaba */ \"./src/sunaba/Sunaba.ts\"));\nvar Token_1 = __importDefault(__webpack_require__(/*! ./Token */ \"./src/sunaba/Token.ts\"));\nvar Parser_1 = __importDefault(__webpack_require__(/*! ./Parser */ \"./src/sunaba/Parser.ts\"));\nvar CodeGenerator_1 = __importDefault(__webpack_require__(/*! ./CodeGenerator */ \"./src/sunaba/CodeGenerator.ts\"));\nvar Assembler_1 = __importDefault(__webpack_require__(/*! ./Assembler */ \"./src/sunaba/Assembler.ts\"));\nvar TokenType_1 = __importDefault(__webpack_require__(/*! ./TokenType */ \"./src/sunaba/TokenType.ts\"));\nvar Compiler = /** @class */ (function () {\n    function Compiler() {\n        this.code = '';\n        this.tokenizedResults = {};\n        this.structurizedResults = {};\n        this.rootNode = {};\n        this.parserResults = {};\n        this.codeGeneratorResults = {};\n        this.vmCommands = [];\n    }\n    Compiler.prototype.compile = function (code) {\n        var errorMessage = '';\n        try {\n            this.compileMain(code + \"\\n\");\n        }\n        catch (e) {\n            errorMessage = e.toString();\n        }\n        return {\n            commands: this.vmCommands,\n            errorMessage: errorMessage,\n        };\n    };\n    Compiler.prototype.compileMain = function (code) {\n        var s = code;\n        s = this.unifySpace(s);\n        s = this.unifyNewLine(s);\n        s = this.replaceChar(s);\n        s = this.unifyOperator(s);\n        s = this.removeSingleLineComment(s);\n        s = this.removeMultiLineComment(s);\n        this.code = s;\n        var locale = Sunaba_1.default.locales.japanese;\n        this.tokenizedResults = this.tokenize(s, locale);\n        this.structurizedResults = this.structurize(this.tokenizedResults.tokens);\n        var parser = new Parser_1.default(this.structurizedResults.tokens, Sunaba_1.default.locales.japanese);\n        this.rootNode = parser.parseProgram();\n        var codeGenerator = new CodeGenerator_1.default();\n        this.codeGeneratorResults = {\n            result: false,\n            commands: [],\n        };\n        this.codeGeneratorResults.result = codeGenerator.generateProgram(this.rootNode);\n        this.codeGeneratorResults.commands = codeGenerator.getCommands();\n        var assembler = new Assembler_1.default();\n        this.vmCommands = assembler.assemble(this.codeGeneratorResults.commands);\n    };\n    Compiler.prototype.unifySpace = function (code) {\n        // SPEC_CHANGE:タブは8個のスペースとして解釈する\n        // 全角スペースは半角2個へ\n        var SPACE_8 = '        ';\n        var SPACE_2 = '  ';\n        var s = code;\n        s = s.replace(/[\\t]/g, SPACE_8);\n        s = s.replace(/[　]/g, SPACE_2);\n        return s;\n    };\n    Compiler.prototype.unifyNewLine = function (code) {\n        // 全てのCR,CRLFをLFに変換する\n        var s = code.replace(/\\r\\n|\\r/g, '\\n');\n        return s;\n    };\n    Compiler.prototype.replaceChar = function (code) {\n        // 1.対応する半角文字がある全角文字を全て半角にする\n        // 2.制御文字は捨てる\n        var len = code.length;\n        var u = function (s) { return s.charCodeAt(0); };\n        var s = '';\n        var LOC_ARG_DELIM = '、'.charCodeAt(0);\n        for (var i = 0; i < len; i += 1) {\n            var c = code.charCodeAt(i);\n            var o = c;\n            if ((c >= u('Ａ')) && (c <= u('Ｚ'))) {\n                o = u('A') + (c - u('Ａ'));\n            }\n            else if ((c >= u('ａ')) && (c <= u('ｚ'))) {\n                o = u('a') + (c - u('ａ'));\n            }\n            else if ((c >= u('０')) && (c <= u('９'))) {\n                o = u('0') + (c - u('０'));\n            }\n            else if (c === u('\\n')) { // 改行は残す\n                o = c;\n            }\n            else if ((c < 0x20) || (c === 0x7f)) {\n                // 0から0x1fまでの制御コードとdelを捨てる。ただし\\nは上で処理済み。\n            }\n            else if (c === LOC_ARG_DELIM) { // 言語ごとの区切り文字\n                o = u(',');\n                // ASCII範囲\n            }\n            else if (c === u('！')) { // 0x21\n                o = u('!');\n            }\n            else if (c === u('”')) { // 0x22\n                o = u('\"');\n            }\n            else if (c === u('＃')) { // 0x23\n                o = u('#');\n            }\n            else if (c === u('＄')) { // 0x24\n                o = u('$');\n            }\n            else if (c === u('％')) { // 0x25\n                o = u('%');\n            }\n            else if (c === u('＆')) { // 0x26\n                o = u('&');\n            }\n            else if (c === u('’')) { // 0x27\n                o = u('\\'');\n            }\n            else if (c === u('（')) { // 0x28\n                o = u('(');\n            }\n            else if (c === u('）')) { // 0x29\n                o = u(')');\n            }\n            else if (c === u('＊')) { // 0x2a\n                o = u('*');\n            }\n            else if (c === u('＋')) { // 0x2b\n                o = u('+');\n            }\n            else if (c === u('，')) { // 0x2c\n                o = u(',');\n            }\n            else if (c === u('－')) { // 0x2d\n                o = u('-');\n            }\n            else if (c === u('．')) { // 0x2e\n                o = u('.');\n            }\n            else if (c === u('／')) { // 0x2f\n                o = u('/');\n            }\n            else if (c === u('：')) { // 0x3a\n                o = u(':');\n            }\n            else if (c === u('；')) { // 0x3b\n                o = u(';');\n            }\n            else if (c === u('＜')) { // 0x3c\n                o = u('<');\n            }\n            else if (c === u('＝')) { // 0x3d\n                o = u('=');\n            }\n            else if (c === u('＞')) { // 0x3e\n                o = u('>');\n            }\n            else if (c === u('？')) { // 0x3f\n                o = u('?');\n            }\n            else if (c === u('＠')) { // 0x40\n                o = u('@');\n            }\n            else if (c === u('［')) { // 0x5b\n                o = u('[');\n            }\n            else if (c === u('＼')) { // 0x5c\n                o = u('\\\\');\n            }\n            else if (c === u('］')) { // 0x5d\n                o = u(']');\n            }\n            else if (c === u('＾')) { // 0x5e\n                o = u('^');\n            }\n            else if (c === u('＿')) { // 0x5f\n                o = u('_');\n            }\n            else if (c === u('‘')) { // 0x60\n                o = u('`');\n            }\n            else if (c === u('｛')) { // 0x7b\n                o = u('{');\n            }\n            else if (c === u('｜')) { // 0x7c\n                o = u('|');\n            }\n            else if (c === u('｝')) { // 0x7d\n                o = u('}');\n            }\n            else if (c === u('～')) { // 0x7e\n                o = u('~');\n                // その他\n            }\n            else if (c === u('×')) {\n                o = u('*');\n            }\n            else if (c === u('÷')) {\n                o = u('/');\n            }\n            else if (c === u('≧')) { // 日本特有のものを世界的にメジャーなものに変換\n                o = u('≥');\n            }\n            else if (c === u('≦')) { // 日本特有のものを世界的にメジャーなものに変換\n                o = u('≤');\n            }\n            else if (c === u('⇒')) { // 代入対応\n                o = u('→');\n            }\n            else {\n                o = c;\n            }\n            s += String.fromCharCode(o);\n        }\n        return s;\n    };\n    Compiler.prototype.unifyOperator = function (code) {\n        // 演算子統一\n        // >=を≥に、 <=を≤に、 !=を≠に、->を→に変換する\n        var s = code;\n        s = s.replace(/>=/g, '≥');\n        s = s.replace(/<=/g, '≤');\n        s = s.replace(/[!]=/g, '≠');\n        s = s.replace(/->/g, '→');\n        return s;\n    };\n    Compiler.prototype.removeSingleLineComment = function (code) {\n        // 行末の #コメントを削除する\n        var LF = '\\n';\n        var SHARP = '#';\n        var len = code.length;\n        var s = '';\n        var inComment = false;\n        for (var i = 0; i < len; i += 1) {\n            var ch = code.substr(i, 1);\n            if (inComment) {\n                if (ch === LF) {\n                    s += LF;\n                    inComment = false;\n                }\n            }\n            else if (code[i] === SHARP) {\n                inComment = true;\n            }\n            else {\n                s += ch;\n            }\n        }\n        return s;\n    };\n    Compiler.prototype.removeMultiLineComment = function (code) {\n        var SLASH = '/';\n        var ASTERISK = '*';\n        var len = code.length;\n        var s = '';\n        var mode = 0;\n        for (var i = 0; i < len; i += 1) {\n            var c = code.substr(i, 1);\n            if (mode === 0) {\n                if (c === SLASH) {\n                    mode = 1;\n                }\n                else {\n                    s += c;\n                }\n            }\n            else if (mode === 1) {\n                if (c === ASTERISK) { // コメント成立\n                    mode = 2;\n                }\n                else {\n                    s += SLASH; // さっきのスラッシュを出力\n                    s += c; // 今回の文字を出力\n                    mode = 0;\n                }\n            }\n            else if (mode === 2) { // コメント中\n                if (c === ASTERISK) { // コメント終了?\n                    mode = 3;\n                }\n            }\n            else if (mode === 3) { // コメント終了?\n                if (c === SLASH) { // 終了！\n                    mode = 0;\n                }\n            }\n            else {\n                throw new Error('BUG');\n            }\n        }\n        return s;\n    };\n    Compiler.prototype.tokenize = function (code, loc) {\n        // トークン分解\n        /*\n          TODO: modeをenum定義する\n        [モード]\n        0 行頭\n        1 行頭以外1文字目\n        2 文字列\n        */\n        var tokens = [];\n        var msg = '';\n        var end = code.length;\n        var mode = 0;\n        var begin = 0;\n        var line = 1;\n        // TODO: u()は削除できる。\n        var u = function (s) { return s; }; // 1文字目のunicodeを返す関数を短く定義\n        var i = 0;\n        while (i < end) {\n            var advance = true;\n            var c = code[i];\n            var l = i - begin; // 現時点でのトークン長\n            if (mode === 0) {\n                if (c === u(' ')) { // 空白が続く限り留まる\n                    // noop\n                }\n                else if (c === u('\\n')) { // 空白しかないまま行を終えたので無視\n                    begin = i + 1; // 開始\n                    line += 1;\n                }\n                else { // 行頭を出力\n                    // tokens.push({type:'LINE_BEGIN', line:line, number:l}); // numberに空白数を入れる\n                    tokens.push(new Token_1.default(TokenType_1.default.TOKEN_LINE_BEGIN, line, '', l)); // numberに空白数を入れる\n                    mode = 1;\n                    advance = false; // この文字もう一度\n                }\n            }\n            else if (mode === 1) { // 行頭以外のトークン先頭\n                if (c === u('(')) {\n                    tokens.push(new Token_1.default(TokenType_1.default.TOKEN_LEFT_BRACKET, line, '('));\n                }\n                else if (c === u(')')) {\n                    tokens.push(new Token_1.default(TokenType_1.default.TOKEN_RIGHT_BRACKET, line, ')'));\n                }\n                else if (c === u('[')) {\n                    tokens.push(new Token_1.default(TokenType_1.default.TOKEN_INDEX_BEGIN, line, '['));\n                }\n                else if (c === u(']')) {\n                    tokens.push(new Token_1.default(TokenType_1.default.TOKEN_INDEX_END, line, ']'));\n                }\n                else if (c === u(',')) {\n                    tokens.push(new Token_1.default(TokenType_1.default.TOKEN_COMMA, line, ','));\n                }\n                else if (c === u('→')) {\n                    tokens.push(new Token_1.default(TokenType_1.default.TOKEN_SUBSTITUTION, line, '→'));\n                }\n                else if (c === u('+')) {\n                    tokens.push(Token_1.default.createcOperater(line, '+'));\n                }\n                else if (c === u('-')) {\n                    tokens.push(Token_1.default.createcOperater(line, '-'));\n                }\n                else if (c === u('*')) {\n                    tokens.push(Token_1.default.createcOperater(line, '*'));\n                }\n                else if (c === u('/')) {\n                    tokens.push(Token_1.default.createcOperater(line, '/'));\n                }\n                else if (c === u('=')) {\n                    tokens.push(Token_1.default.createcOperater(line, '='));\n                }\n                else if (c === u('≠')) {\n                    tokens.push(Token_1.default.createcOperater(line, '≠'));\n                }\n                else if (c === u('<')) {\n                    tokens.push(Token_1.default.createcOperater(line, '<'));\n                }\n                else if (c === u('>')) {\n                    tokens.push(Token_1.default.createcOperater(line, '>'));\n                }\n                else if (c === u('≤')) {\n                    tokens.push(Token_1.default.createcOperater(line, '≤'));\n                }\n                else if (c === u('≥')) {\n                    tokens.push(Token_1.default.createcOperater(line, '≥'));\n                }\n                else if (c === u('\\n')) { // 行末\n                    mode = 0;\n                    begin = i + 1;\n                    line += 1;\n                }\n                else if (c === u(' ')) { // 空白が来た\n                    // 何もしない\n                }\n                else if (Sunaba_1.default.isInName(c)) { // 識別子開始\n                    mode = 2;\n                    begin = i;\n                }\n                else {\n                    msg = \"E001: \\u884C\" + line + \": Sunaba\\u3067\\u4F7F\\u3046\\u306F\\u305A\\u306E\\u306A\\u3044\\u6587\\u5B57'\" + c + \"'\\u304C\\u51FA\\u3066\\u304D\\u305F\\u3002\\n\";\n                    if (c === ';') {\n                        msg += 'C言語と違って文末の;は不要。';\n                    }\n                    else if ((c === '{') || (c === '}')) {\n                        msg += 'C言語と違って{や}は使わない。行頭の空白で構造を示す。';\n                    }\n                    break;\n                }\n            }\n            else if (mode === 2) { // 識別子\n                if (Sunaba_1.default.isInName(c)) { // 続く\n                    // noop\n                }\n                else { // その他の場合、出力\n                    var str = code.substr(begin, l);\n                    var tokenType = Sunaba_1.default.readKeyword(str, loc); // キーワード\n                    if (tokenType !== TokenType_1.default.TOKEN_UNKNOWN) {\n                        tokens.push(new Token_1.default(tokenType, line, str));\n                    }\n                    else {\n                        var number = Sunaba_1.default.readNumber(code, begin, l);\n                        if (!isNaN(number)) {\n                            if (Math.abs(number) > Sunaba_1.default.MAX_ABS_NUMBER) {\n                                msg = \"E002: \\u884C\" + line + \": Sunaba\\u3067\\u306F\\u6271\\u3048\\u306A\\u3044\\u5927\\u304D\\u306A\\u6570\" + number + \"\\u304C\\u73FE\\u308C\\u307E\\u3057\\u305F\\u3002\\n\";\n                                msg += \"\\u30D7\\u30E9\\u30B9\\u30DE\\u30A4\\u30CA\\u30B9\" + Sunaba_1.default.MAX_ABS_NUMBER + \"\\u306E\\u7BC4\\u56F2\\u3057\\u304B\\u4F7F\\u3048\\u307E\\u305B\\u3093\\u3002\";\n                                break;\n                            }\n                            else {\n                                tokens.push(new Token_1.default(TokenType_1.default.TOKEN_NUMBER, line, str, number));\n                            }\n                        }\n                        else { // キーワードでも数字でもないので名前\n                            tokens.push(new Token_1.default(TokenType_1.default.TOKEN_NAME, line, str));\n                        }\n                    }\n                    mode = 1;\n                    advance = false; // もう一回この文字から回す\n                }\n            }\n            else {\n                throw new Error('BUG: Compiler.ts:405');\n            }\n            if (advance) {\n                i += 1;\n            }\n        }\n        if (msg.length > 0) {\n            throw msg;\n        }\n        return {\n            tokens: tokens,\n            errorMessage: msg,\n        };\n    };\n    Compiler.prototype.structurize = function (tokens) {\n        var r = [];\n        var spaceCountStack = [0];\n        var spaceCountStackPos = 1;\n        var parenLevel = 0;\n        var braceLevel = 0;\n        var msg = '';\n        var prevT = null;\n        var emptyLine = true; // 最初は空\n        for (var i = 0; i < tokens.length; i += 1) {\n            var t = tokens[i];\n            if (t.type === TokenType_1.default.TOKEN_LEFT_BRACKET) {\n                parenLevel += 1;\n            }\n            else if (t.type === TokenType_1.default.TOKEN_RIGHT_BRACKET) {\n                parenLevel -= 1;\n                if (parenLevel < 0) {\n                    msg = \"E010: \\u884C\" + t.line + \": )\\u304C(\\u3088\\u308A\\u591A\\u3044\\u3002\";\n                    break;\n                }\n            }\n            else if (t.type === TokenType_1.default.TOKEN_INDEX_BEGIN) {\n                braceLevel += 1;\n            }\n            else if (t.type === TokenType_1.default.TOKEN_INDEX_END) {\n                braceLevel -= 1;\n                if (braceLevel < 0) {\n                    msg = \"E011: \\u884C:\" + t.line + \": ]\\u304C[\\u3088\\u308A\\u591A\\u3044\\u3002\";\n                    break;\n                }\n            }\n            if (t.type === TokenType_1.default.TOKEN_LINE_BEGIN) { // 行頭\n                var prevIsOp = false; // 前のトークンは演算子か代入か？\n                if ((prevT !== null) && ((prevT.type === TokenType_1.default.TOKEN_OPERATOR) || (prevT.type === TokenType_1.default.TOKEN_SUBSTITUTION))) {\n                    prevIsOp = true;\n                }\n                // ()や[]の中におらず、前のトークンが演算子や代入記号でなければ、\n                if ((parenLevel === 0) && (braceLevel === 0) && (!prevIsOp)) {\n                    if (t.number === undefined) {\n                        // インデント量が入っているはず\n                        throw new Error('BUG インデント量が入っていない');\n                    }\n                    var newCount = t.number;\n                    var oldCount = spaceCountStack[spaceCountStackPos - 1];\n                    if (newCount > oldCount) { // 増えた\n                        spaceCountStack[spaceCountStackPos] = newCount;\n                        spaceCountStackPos += 1;\n                        r.push(new Token_1.default(TokenType_1.default.TOKEN_BLOCK_BEGIN, t.line, 'ブロック開始'));\n                    }\n                    else if (newCount === oldCount) {\n                        if (!emptyLine) { // 空行でなければ\n                            r.push(new Token_1.default(TokenType_1.default.TOKEN_STATEMENT_END, t.line, '行末'));\n                            emptyLine = true;\n                        }\n                    }\n                    else { // newCount < oldCount\n                        if (!emptyLine) { // 空行でなければ\n                            r.push(new Token_1.default(TokenType_1.default.TOKEN_STATEMENT_END, t.line, '行末'));\n                            emptyLine = true;\n                        }\n                        while (newCount < oldCount) { // ずれてる間回す\n                            spaceCountStackPos -= 1;\n                            if (spaceCountStackPos < 1) { // ありえない\n                                throw new Error('BUG: compipler.ts:472');\n                            }\n                            oldCount = spaceCountStack[spaceCountStackPos - 1];\n                            r.push(new Token_1.default(TokenType_1.default.TOKEN_BLOCK_END, t.line, 'ブロック末'));\n                        }\n                        if (newCount !== oldCount) { // ずれている\n                            msg = \"E012: \\u884C\" + t.line + \": \\u5B57\\u4E0B\\u3052\\u304C\\u4E0D\\u6B63\\u3002\\u305A\\u308C\\u3066\\u308B\\u3088\\u3002\\u524D\\u306E\\u6DF1\\u3055\\u306B\\u5408\\u308F\\u305B\\u3066\\u306D\\u3002\";\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                r.push(t); // そのまま移植\n                emptyLine = false; // 空行ではなくなった\n            }\n            prevT = t;\n        }\n        if (!emptyLine) { // 最後の行を終わらせる\n            var line = prevT ? prevT.line : 0;\n            r.push(new Token_1.default(TokenType_1.default.TOKEN_STATEMENT_END, line, '行末'));\n        }\n        // ブロック終了を補う\n        while (spaceCountStackPos > 1) {\n            spaceCountStackPos -= 1;\n            var line = prevT ? prevT.line : 0;\n            r.push(new Token_1.default(TokenType_1.default.TOKEN_BLOCK_END, line, 'ブロック末'));\n        }\n        // ダミー最終トークン\n        r.push(new Token_1.default(TokenType_1.default.TOKEN_END, tokens[tokens.length - 1].line));\n        if (msg.length > 0) {\n            throw new Error(msg);\n        }\n        return {\n            errorMessage: msg,\n            tokens: r,\n        };\n    };\n    return Compiler;\n}());\nexports.default = Compiler;\n\n\n//# sourceURL=webpack:///./src/sunaba/Compiler.ts?");

/***/ }),

/***/ "./src/sunaba/FunctionGenerator.ts":
/*!*****************************************!*\
  !*** ./src/sunaba/FunctionGenerator.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__filename) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint\n  no-unused-vars: 0,\n  no-console: 0\n */\nvar HLib_1 = __importDefault(__webpack_require__(/*! ./HLib */ \"./src/sunaba/HLib.ts\"));\nvar FunctionInfo_1 = __importDefault(__webpack_require__(/*! ./FunctionInfo */ \"./src/sunaba/FunctionInfo.ts\"));\nvar TokenType_1 = __importDefault(__webpack_require__(/*! ./TokenType */ \"./src/sunaba/TokenType.ts\"));\nvar NodeType_1 = __webpack_require__(/*! ./NodeType */ \"./src/sunaba/NodeType.ts\");\nvar AsmCommand_1 = __importDefault(__webpack_require__(/*! ./AsmCommand */ \"./src/sunaba/AsmCommand.ts\"));\nvar Variable = /** @class */ (function () {\n    function Variable() {\n        this.mDefined = false;\n        this.mInitialized = false;\n        this.mOffset = 0;\n    }\n    Variable.prototype.set = function (address) {\n        this.mOffset = address;\n    };\n    Variable.prototype.define = function () {\n        this.mDefined = true;\n    };\n    Variable.prototype.initialize = function () {\n        this.mInitialized = true;\n    };\n    Variable.prototype.isDefined = function () {\n        return this.mDefined;\n    };\n    Variable.prototype.isInitialized = function () {\n        return this.mInitialized;\n    };\n    Variable.prototype.offset = function () {\n        return this.mOffset;\n    };\n    return Variable;\n}());\nvar Block = /** @class */ (function () {\n    function Block(baseOffset) {\n        this.mParent = null;\n        this.mBaseOffset = baseOffset;\n        this.mFrameSize = 0;\n        this.stream = function (s) {\n            console.log(s);\n        };\n        this.mVariables = {};\n    }\n    Block.prototype.beginError = function (node) {\n        var token = node.token;\n        HLib_1.default.assert(token, __filename + \":59\");\n        var s = '';\n        if (token.line !== 0) {\n            s = \"(\" + token.line + \")\";\n        }\n        else {\n            s = ' ';\n        }\n        this.stream(s);\n    };\n    Block.prototype.addVariable = function (name, isArgument) {\n        if (isArgument === void 0) { isArgument = false; }\n        if (name in this.mVariables) {\n            return false;\n        }\n        var retVar = new Variable();\n        retVar.set(this.mBaseOffset + this.mFrameSize);\n        this.mFrameSize += 1;\n        if (isArgument) { // 引数なら定義済みかつ初期化済み\n            retVar.define();\n            retVar.initialize();\n        }\n        this.mVariables[name] = retVar;\n        return true;\n    };\n    Block.prototype.collectVariables = function (firstStatement) {\n        var statement = firstStatement;\n        while (statement) {\n            // 代入文なら、変数名を取得して登録。\n            if (statement.type === NodeType_1.NodeType.NODE_SUBSTITUTION_STATEMENT) {\n                var left = statement.child;\n                HLib_1.default.assert(left, __filename + \":92\");\n                if (left.type === NodeType_1.NodeType.NODE_VARIABLE) { // 変数への代入文のみ扱う。配列要素や定数は無視。\n                    HLib_1.default.assert(left.token, __filename + \":95\");\n                    var vName = left.token.string;\n                    // ここより上にこの変数があるか調べる。\n                    var v = this.findVariable(vName);\n                    if (!v) {\n                        // ない。新しい変数を生成\n                        if (!this.addVariable(vName)) {\n                            // ありえん\n                            HLib_1.default.assert(false, __filename + \":104\");\n                        }\n                    }\n                }\n            }\n            statement = statement.brother;\n        }\n    };\n    Block.prototype.findVariable = function (name) {\n        if (this.mVariables[name] !== undefined) {\n            // 自分にあった。\n            return this.mVariables[name];\n        }\n        if (this.mParent) {\n            // 親がいる\n            return this.mParent.findVariable(name);\n        }\n        return null;\n    };\n    return Block;\n}());\nvar OffsetParams = /** @class */ (function () {\n    function OffsetParams() {\n        this.fpRelative = false;\n        this.staticOffset = 0;\n    }\n    OffsetParams.prototype.setFpRelative = function (fpRelative) {\n        this.fpRelative = fpRelative;\n    };\n    OffsetParams.prototype.setStaticOffset = function (staticOffset) {\n        this.staticOffset = staticOffset;\n    };\n    return OffsetParams;\n}());\nvar FunctionGenerator = /** @class */ (function () {\n    function FunctionGenerator(codeGen) {\n        this.codeGen = codeGen;\n        this.cmds = [];\n        this.mRootBlock = new Block(0); // dummy\n        this.mCurrentBlock = new Block(0); // dummy\n        this.mLabelId = 0;\n        this.mName = '';\n        this.mInfo = new FunctionInfo_1.default(); // dummy\n        this.mFunctionMap = codeGen.mFunctionMap;\n        this.mOutputExist = false;\n    }\n    FunctionGenerator.prototype.addCommand = function (name, imm, comment) {\n        if (imm === void 0) { imm = 0; }\n        if (comment === void 0) { comment = ''; }\n        var cmd = new AsmCommand_1.default('', name, imm, comment);\n        this.cmds.push(cmd);\n    };\n    FunctionGenerator.prototype.addLabel = function (label, comment) {\n        if (comment === void 0) { comment = ''; }\n        var cmd = new AsmCommand_1.default(label, '', 0, comment);\n        this.cmds.push(cmd);\n    };\n    FunctionGenerator.prototype.mergeCommands = function (cmds) {\n        var _this = this;\n        cmds.forEach(function (item) {\n            _this.cmds.push(item);\n        });\n    };\n    FunctionGenerator.prototype.getCommands = function () {\n        return this.cmds;\n    };\n    // E200\n    FunctionGenerator.prototype.process = function (node, funcName) {\n        this.mName = funcName;\n        this.mInfo = this.mFunctionMap[this.mName];\n        // 後でエラー出力に使うのでとっておく。\n        var headNode = node;\n        // FP相対オフセットを計算\n        var argCount = this.mInfo.argCount();\n        // ルートブロック生成(TODO:このnew本来不要。コンストラクタでスタックに持つようにできるはず)\n        this.mRootBlock = new Block(-argCount - 3); // 戻り値、引数*N、FP、CPと詰めたところが今のFP。戻り値の位置は-argcount-3\n        this.mCurrentBlock = this.mRootBlock;\n        // 戻り値変数を変数マップに登録\n        this.mCurrentBlock.addVariable('!ret');\n        // 引数処理\n        // みつかった順にアドレスを割り振りながらマップに登録。\n        // 呼ぶ時は前からプッシュし、このあとFP,PCをプッシュしたところがSPになる。\n        var child = node.child;\n        while (child) { // このループを抜けた段階で最初のchildは最初のstatementになっている\n            if (child.type !== NodeType_1.NodeType.NODE_VARIABLE) {\n                break;\n            }\n            if (child.token === null) {\n                throw new Error(\"child.token === null, \" + __filename + \":195\");\n            }\n            var variableName = child.token.string;\n            if (!this.mCurrentBlock.addVariable(variableName, true)) {\n                this.beginError(node);\n                throw new Error(\"E201: \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0'\" + this.mName + \"'\\u306E\\u5165\\u529B'\" + variableName + \"\\u306F\\u3082\\u3046\\u3059\\u3067\\u306B\\u73FE\\u308C\\u305F\\u3002\\u4E8C\\u500B\\u540C\\u3058\\u540D\\u524D\\u304C\\u3042\\u308B\\u306E\\u306F\\u30C0\\u30E1\\u3002\");\n            }\n            child = child.brother;\n        }\n        // FP、CPを変数マップに登録(これで処理が簡単になる)\n        this.mCurrentBlock.addVariable('!fp');\n        this.mCurrentBlock.addVariable('!cp');\n        // ルートブロックのローカル変数サイズを調べる\n        this.mRootBlock.collectVariables(child);\n        // 関数開始コメント\n        this.addCommand('', 0, \"#\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\\"\" + this.mName + \"\\\"\\u306E\\u958B\\u59CB\\n\");\n        // 関数開始ラベル\n        // 160413: add等のアセンブラ命令と同名の関数があった時にラベルを命令と間違えて誤作動する問題の緊急回避\n        this.addLabel(\"func_\" + this.mName);\n        // ローカル変数を確保\n        // 戻り値、FP、CP、引数はここで問題にするローカル変数ではない。呼出側でプッシュしているからだ。\n        var netFrameSize = this.mCurrentBlock.mFrameSize - 3 - argCount;\n        if (netFrameSize > 0) {\n            // -1は戻り値を入れてしまった分\n            this.addCommand('pop', -netFrameSize, '#ローカル変数確保');\n        }\n        // 中身を処理\n        while (child) {\n            if (!this.generateStatement(child)) {\n                return false;\n            }\n            child = child.brother;\n        }\n        // 関数終了点ラベル。上のループの中でreturnがあればここに飛んでくる。\n        // \tthis.addLabel(`${this.mName}_end:`);\n        // ret生成(ローカル変数)\n        this.addCommand('ret', netFrameSize, \"#\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\\"\" + this.mName + \"\\u306E\\u7D42\\u4E86\");\n        // 出力の整合性チェック。\n        // ifの中などで出力してるのに、ブロック外に出力がないケースを検出\n        if (this.mInfo.hasOutputValue() !== this.mOutputExist) {\n            HLib_1.default.assert(this.mOutputExist, __filename + \":245\"); // outputExistがfalseで、hasOutputValue()がtrueはありえない\n            if (headNode.token) {\n                // 普通の関数ノード\n                this.beginError(headNode);\n                throw new Error(\"E202: \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0'\" + this.mName + \"'\\u306F\\u51FA\\u529B\\u3057\\u305F\\u308A\\u3057\\u306A\\u304B\\u3063\\u305F\\u308A\\u3059\\u308B\\u3002\\u6761\\u4EF6\\u5B9F\\u884C\\u3084\\u7E70\\u308A\\u8FD4\\u3057\\u306E\\u4E2D\\u3060\\u3051\\u3067\\u51FA\\u529B\\u3057\\u3066\\u3044\\u306A\\u3044\\u304B\\uFF1F\");\n            }\n            else {\n                // プログラムノード\n                HLib_1.default.assert(headNode.child !== null, __filename + \":252\");\n                this.beginError(headNode.child);\n                throw new Error('E203: このプログラムは出力したりしなかったりする。条件実行や繰り返しの中だけで出力していないか？');\n            }\n        }\n        return true;\n    };\n    FunctionGenerator.prototype.generateStatement = function (node) {\n        // ブロック生成命令は別扱い\n        if ((node.type === NodeType_1.NodeType.NODE_WHILE_STATEMENT) || (node.type === NodeType_1.NodeType.NODE_IF_STATEMENT)) {\n            // 新ブロック生成\n            var newBlock = new Block(this.mCurrentBlock.mBaseOffset + this.mCurrentBlock.mFrameSize);\n            newBlock.mParent = this.mCurrentBlock; // 親差し込み\n            newBlock.collectVariables(node.child); // フレーム生成\n            this.mCurrentBlock = newBlock;\n            // ローカル変数を確保\n            if (this.mCurrentBlock.mFrameSize > 0) {\n                this.addCommand('pop', -(this.mCurrentBlock.mFrameSize), '#ブロックローカル変数確保');\n            }\n            if (node.type === NodeType_1.NodeType.NODE_WHILE_STATEMENT) {\n                if (!this.generateWhile(node)) {\n                    return false;\n                }\n            }\n            else if (node.type === NodeType_1.NodeType.NODE_IF_STATEMENT) {\n                if (!this.generateIf(node)) {\n                    return false;\n                }\n            }\n            // ローカル変数ポップ\n            if (this.mCurrentBlock.mFrameSize > 0) {\n                this.addCommand('pop', this.mCurrentBlock.mFrameSize, '#ブロックローカル変数破棄');\n            }\n            if (this.mCurrentBlock.mParent === null) {\n                throw new Error(\"BUG: this.mCurrentBlock.mParent === null \" + __filename + \":#298\");\n            }\n            this.mCurrentBlock = this.mCurrentBlock.mParent; // スタック戻し\n        }\n        else if (node.type === NodeType_1.NodeType.NODE_SUBSTITUTION_STATEMENT) {\n            if (!this.generateSubstitution(node)) {\n                return false;\n            }\n        }\n        else if (node.type === NodeType_1.NodeType.NODE_FUNCTION) {\n            // 関数だけ呼んで結果を代入しない文\n            if (!this.generateFunctionStatement(node)) {\n                return false;\n            }\n        }\n        else if (node.type === NodeType_1.NodeType.NODE_FUNCTION_DEFINITION) {\n            // 関数定義はもう処理済みなので無視。\n            // スルー\n        }\n        else {\n            HLib_1.default.assert(false, __filename + \":305 node.type:\" + node.type);\n        }\n        return true;\n    };\n    /*\n    ブロック開始処理に伴うローカル変数確保を行い、\n  \n    1の間ループ.0ならループ後にジャンプと置き換える。\n  \n    whileBegin:\n    Expression;\n    push 0\n    eq\n    b whileEnd\n    Statement ...\n    push 1\n    b whileBegin // 最初へ\n    whileEnd:\n    */\n    FunctionGenerator.prototype.generateWhile = function (node) {\n        HLib_1.default.assert(node.type === NodeType_1.NodeType.NODE_WHILE_STATEMENT, __filename + \":327\");\n        if (node.child === null) {\n            throw new Error(\"BUG node.child === null \" + node.type + \" \" + __filename + \":339\");\n        }\n        // 開始ラベル\n        var whileBegin = this.mName + \"_whileBegin\" + this.mLabelId;\n        var whileEnd = this.mName + \"_whileEnd\" + this.mLabelId;\n        this.mLabelId += 1;\n        this.addLabel(whileBegin);\n        // Expression処理\n        var child = node.child;\n        if (!this.generateExpression(child)) {\n            // 最初の子はExpression\n            return false;\n        }\n        // いくつかコード生成\n        this.addCommand('bz', whileEnd);\n        // 内部の文を処理\n        var bro = child.brother;\n        while (bro) {\n            if (!this.generateStatement(bro)) {\n                return false;\n            }\n            bro = bro.brother;\n        }\n        // ループの最初へ飛ぶジャンプを生成\n        this.addCommand('j', whileBegin, '#ループ先頭へ無条件ジャンプ');\n        // ループ終了ラベルを生成\n        this.addLabel(whileEnd);\n        return true;\n    };\n    /*\n    1なら直下を実行.0ならif文末尾にジャンプと置き換える\n    Expression\n    push 0\n    eq\n    b ifEnd\n    Statement...\n    ifEnd:\n    */\n    FunctionGenerator.prototype.generateIf = function (node) {\n        HLib_1.default.assert(node.type === NodeType_1.NodeType.NODE_IF_STATEMENT, __filename + \":375\");\n        if (node.child === null) {\n            throw new Error(\"BUG node.child === null \" + node.type + \" \" + __filename + \":389\");\n        }\n        // Expression処理\n        var child = node.child;\n        if (!this.generateExpression(child)) {\n            // 最初の子はExpression\n            return false;\n        }\n        // コード生成\n        var label_ifEnd = this.mName + \"_ifEnd\" + this.mLabelId;\n        this.mLabelId += 1;\n        this.addCommand('bz', label_ifEnd);\n        // 内部の文を処理\n        while (child.brother) {\n            child = child.brother;\n            if (!this.generateStatement(child)) {\n                return false;\n            }\n        }\n        // ラベル生成\n        this.addLabel(label_ifEnd);\n        return true;\n    };\n    FunctionGenerator.prototype.generateFunctionStatement = function (node) {\n        // まず関数呼び出し\n        if (!this.generateFunction(node, true)) {\n            return false;\n        }\n        // 関数の戻り値がプッシュされているので捨てます。\n        // this.addCommandg('pop', 1, '#戻り値を使わないので、破棄');\n        return true;\n    };\n    // E210\n    FunctionGenerator.prototype.generateFunction = function (node, isStatement) {\n        HLib_1.default.assert(node.type === NodeType_1.NodeType.NODE_FUNCTION, __filename + \":420\");\n        if (node.token === null) {\n            throw new Error(\"BUG node.child === null \" + node.type + \" \" + __filename + \":435\");\n        }\n        // まず、その関数が存在していて、定義済みかを調べる。\n        var funcName = node.token.string;\n        if (!(funcName in this.mFunctionMap)) {\n            this.beginError(node);\n            throw new Error(\"E210: \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0'\" + funcName + \"'\\u306A\\u3093\\u3066\\u77E5\\u3089\\u306A\\u3044\\u3002\");\n        }\n        var func = this.mFunctionMap[funcName];\n        var popCount = 0; // 後で引数/戻り値分ポップ\n        if (func.hasOutputValue()) {\n            // 戻り値あるならプッシュ\n            this.addCommand('pop', -1, \"#\" + funcName + \"\\u306E\\u623B\\u308A\\u5024\\u9818\\u57DF\");\n            if (isStatement) {\n                // 戻り値を使わないのでポップ数+1\n                popCount += 1;\n            }\n        }\n        else if (!isStatement) {\n            // 戻り値がないなら式の中にあっちゃだめ\n            this.beginError(node);\n            throw new Error(\"E211: \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0'\" + funcName + \"'\\u306F\\u3001'\\u51FA\\u529B'\\u304B'out'\\u3068\\u3044\\u3046\\u540D\\u524D\\u4ED8\\u304D\\u30E1\\u30E2\\u30EA\\u304C\\u306A\\u3044\\u306E\\u3067\\u3001\\u51FA\\u529B\\u306F\\u4F7F\\u3048\\u306A\\u3044\\u3002if\\u3084while\\u306E\\u4E2D\\u306B\\u3042\\u3063\\u3066\\u3082\\u30C0\\u30E1\\u3002\");\n        }\n        // 引数の数をチェック\n        var arg = node.child;\n        var argCount = 0;\n        while (arg) {\n            argCount += 1;\n            arg = arg.brother;\n        }\n        popCount += argCount; // 引数分追加\n        if (argCount !== func.argCount()) {\n            this.beginError(node);\n            throw new Error(\"E212: \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0'\" + funcName + \"'\\u306F\\u3001\\u5165\\u529B\\u3092\" + func.argCount() + \"\\u500B\\u53D7\\u3051\\u53D6\\u308B\\u306E\\u306B\\u3001\\u3053\\u3053\\u306B\\u306F$$argCount}\\u500B\\u3042\\u308B\\u3002\\u9593\\u9055\\u3044\\u3002\");\n        }\n        // 引数を評価してプッシュ\n        arg = node.child;\n        while (arg) {\n            if (!this.generateExpression(arg)) {\n                return false;\n            }\n            arg = arg.brother;\n        }\n        // call命令生成\n        // 160413: add等のアセンブラ命令と同名の関数があった時にラベルを命令と間違えて誤作動する問題の緊急回避\n        var label = \"func_\" + funcName;\n        this.addCommand('call', label);\n        // 返ってきたら、引数/戻り値をポップ\n        if (popCount > 0) {\n            this.addCommand('pop', popCount, '#引数/戻り値ポップ');\n        }\n        return true;\n    };\n    /*\n    LeftValue\n    Expression\n    st\n    */\n    // E220\n    FunctionGenerator.prototype.generateSubstitution = function (node) {\n        HLib_1.default.assert(node.type === NodeType_1.NodeType.NODE_SUBSTITUTION_STATEMENT, __filename + \":489\");\n        // 左辺値のアドレスを求める。最初の子が左辺値\n        if (node.child === null) {\n            HLib_1.default.assert(false, __filename + \":496\");\n            return false;\n        }\n        var child = node.child;\n        // 変数の定義状態を参照\n        var v = null;\n        if ((child.type === NodeType_1.NodeType.NODE_OUT) || child.token) { // 変数があるなら\n            var name_1 = child.token.string || '';\n            if (child.type === NodeType_1.NodeType.NODE_OUT) {\n                name_1 = '!ret';\n            }\n            v = this.mCurrentBlock.findVariable(name_1);\n            if (!v) {\n                // 配列アクセス時でタイプミスすると変数が存在しないケースがある\n                this.beginError(child);\n                throw new Error(\"E220:\\u540D\\u524D\\u4ED8\\u304D\\u30E1\\u30E2\\u30EA\\u304B\\u5B9A\\u6570'\" + name_1 + \"'\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u304B\\u3001\\u307E\\u3060\\u4F5C\\u3089\\u308C\\u3066\\u3044\\u306A\\u3044\\u3002\");\n            }\n            else if (!(v.isDefined())) { // 未定義ならここで定義\n                v.define();\n            }\n        }\n        var params = new OffsetParams();\n        if (!this.pushDynamicOffset(params, child)) {\n            return false;\n        }\n        // 右辺処理\n        if (child.brother === null) {\n            HLib_1.default.assert(false, __filename + \":529\");\n            return false;\n        }\n        if (!this.generateExpression(child.brother)) {\n            return false;\n        }\n        var cmd;\n        if (params.fpRelative) {\n            cmd = 'fst';\n        }\n        else {\n            cmd = 'st';\n        }\n        var name = node.token.string || '';\n        this.addCommand(cmd, params.staticOffset, \"#\\\"\" + name + \"\\\"\\u3078\\u30B9\\u30C8\\u30A2\");\n        // 左辺値は初期化されたのでフラグをセット。すでにセットされていても気にしない。\n        if (v) {\n            v.initialize();\n        }\n        return true;\n    };\n    // 第一項、第二項、第二項オペレータ、第三項、第三項オペレータ...という具合に実行\n    FunctionGenerator.prototype.generateExpression = function (node) {\n        // 解決されて単項になっていれば、そのままgenerateTermに丸投げ。ただし単項マイナスはここで処理。\n        var ret = false;\n        if (node.type !== NodeType_1.NodeType.NODE_EXPRESSION) {\n            ret = this.generateTerm(node);\n        }\n        else {\n            if (node.negation) {\n                this.addCommand('i', 0, '#()に対する単項マイナス用');\n            }\n            // 項は必ず二つある。\n            if (node.child === null) {\n                HLib_1.default.assert(false, __filename + \":556\");\n                return false;\n            }\n            if (node.child.brother === null) {\n                HLib_1.default.assert(false, __filename + \":557\");\n                return false;\n            }\n            if (!this.generateTerm(node.child)) {\n                return false;\n            }\n            if (!this.generateTerm(node.child.brother)) {\n                return false;\n            }\n            // 演算子を適用\n            var op = this.getOpFromOperator(node.operator);\n            this.addCommand(op);\n            // 単項マイナスがある場合、ここで減算\n            if (node.negation) {\n                this.addCommand('sub', '', '#()に対する単項マイナス用');\n            }\n            ret = true;\n        }\n        return ret;\n    };\n    FunctionGenerator.prototype.getOpFromOperator = function (operator) {\n        var table = {\n            '+': 'add',\n            '-': 'sub',\n            '*': 'mul',\n            '/': 'div',\n            '<': 'lt',\n            '≤': 'le',\n            '=': 'eq',\n            '≠': 'ne',\n        };\n        if (!(operator in table)) {\n            // これはParserのバグ。とりわけ、LE、GEは前の段階でGT,LTに変換されていることに注意\n            HLib_1.default.assert(false, __filename + \":595 unkown operator: \" + operator);\n        }\n        return table[operator];\n    };\n    // E230\n    FunctionGenerator.prototype.generateTerm = function (node) {\n        // 単項マイナス処理0から引く\n        if (node.negation) {\n            // 0をプッシュ\n            this.addCommand('i', 0, '#単項マイナス用');\n        }\n        // タイプで分岐\n        if (node.type === NodeType_1.NodeType.NODE_EXPRESSION) {\n            if (!this.generateExpression(node)) {\n                return false;\n            }\n        }\n        else if (node.type === NodeType_1.NodeType.NODE_NUMBER) {\n            // 数値は即値プッシュ\n            this.addCommand('i', node.number, '#即値プッシュ');\n        }\n        else if (node.type === NodeType_1.NodeType.NODE_FUNCTION) {\n            if (!this.generateFunction(node, false)) {\n                return false;\n            }\n        }\n        else {\n            // ARRAY_ELEMENT,VARIABLEのアドレスプッシュ処理\n            // 変数の定義状態を参照\n            if (node.token) { // 変数があるなら\n                var name_2 = node.token.string;\n                if (node.type === NodeType_1.NodeType.NODE_OUT) {\n                    name_2 = '!ret';\n                }\n                var v = this.mCurrentBlock.findVariable(name_2);\n                // 知らない変数。みつからないか、あるんだがまだその行まで行ってないか。\n                if (!v) {\n                    this.beginError(node);\n                    throw new Error(\"E230:\\u540D\\u524D\\u4ED8\\u304D\\u30E1\\u30E2\\u30EA\\u304B\\u5B9A\\u6570'\" + name_2 + \"'\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u3002\");\n                }\n                if (!(v.isDefined())) {\n                    this.beginError(node);\n                    throw new Error(\"E231:\\u540D\\u524D\\u4ED8\\u304D\\u30E1\\u30E2\\u30EA\\u304B\\u5B9A\\u6570'\" + name_2 + \"'\\u306F\\u307E\\u3060\\u4F5C\\u3089\\u308C\\u3066\\u3044\\u306A\\u3044\\u3002\");\n                }\n                if (!(v.isInitialized())) {\n                    this.beginError(node);\n                    throw new Error(\"E232: \\u540D\\u524D\\u4ED8\\u304D\\u30E1\\u30E2\\u30EA\\u304B\\u5B9A\\u6570'\" + name_2 + \"'\\u306F\\u6570\\u3092\\u30BB\\u30C3\\u30C8\\u3055\\u308C\\u308B\\u524D\\u306B\\u4F7F\\u308F\\u308C\\u3066\\u3044\\u308B\\u3002\\u300Ca->a\\u300D\\u307F\\u305F\\u3044\\u306A\\u306E\\u306F\\u30C0\\u30E1\\u3002\");\n                }\n            }\n            var params = new OffsetParams();\n            if (!this.pushDynamicOffset(params, node)) {\n                return false;\n            }\n            var cmd = void 0;\n            if (params.fpRelative) {\n                cmd = 'fld';\n            }\n            else {\n                cmd = 'ld';\n            }\n            var comment = '\\n';\n            if (node.token) {\n                comment = \"#\\u5909\\u6570'\" + node.token.string + \"'\\u304B\\u3089\\u30ED\\u30FC\\u30C9\";\n            }\n            this.addCommand(cmd, params.staticOffset, comment);\n        }\n        // 単項マイナスがある場合、ここで減算\n        if (node.negation) {\n            this.addCommand('sub', 0, '#単項マイナス用');\n        }\n        return true;\n    };\n    FunctionGenerator.prototype.pushDynamicOffset = function (params, node) {\n        params.setFpRelative(false);\n        params.setStaticOffset(-0x7fffffff); // あからさまにおかしな値を入れておく。デバグのため。\n        HLib_1.default.assert((node.type === NodeType_1.NodeType.NODE_OUT) || (node.type === NodeType_1.NodeType.NODE_VARIABLE) || (node.type === NodeType_1.NodeType.NODE_ARRAY_ELEMENT), __filename + \":684\");\n        // トークンは数字ですか、名前ですか\n        if (node.token) {\n            if (node.token.type === TokenType_1.default.TOKEN_OUT) {\n                var name_3 = '!ret';\n                var v = this.mCurrentBlock.findVariable(name_3);\n                if (v === null) {\n                    HLib_1.default.assert(false, __filename + \":710\");\n                    return false;\n                }\n                params.setFpRelative(true); // 変数直のみFP相対\n                params.setStaticOffset(v.offset());\n                this.mOutputExist = true;\n            }\n            else if (node.token.type === TokenType_1.default.TOKEN_NAME) {\n                // 変数の定義状態を参照\n                var name_4 = node.token.string;\n                var v = this.mCurrentBlock.findVariable(name_4);\n                if (v === null) {\n                    HLib_1.default.assert(false, __filename + \":710\");\n                    return false;\n                }\n                // 配列ならExpressionを評価してプッシュ\n                if (node.type === NodeType_1.NodeType.NODE_ARRAY_ELEMENT) {\n                    this.addCommand('fld', v.offset(), \"#\\u30DD\\u30A4\\u30F3\\u30BF'\" + name_4 + \"'\\u304B\\u3089\\u30ED\\u30FC\\u30C9\");\n                    if (node.child) { // 変数インデクス\n                        if (!this.generateExpression(node.child)) { // アドレスオフセットがプッシュされる\n                            return false;\n                        }\n                        this.addCommand('add');\n                        params.setStaticOffset(0);\n                    }\n                    else { // 定数インデクス\n                        params.setStaticOffset(node.number);\n                    }\n                }\n                else {\n                    params.setFpRelative(true); // 変数直のみFP相対\n                    params.setStaticOffset(v.offset());\n                }\n            }\n        }\n        else {\n            // 定数アクセス。トークンがない。\n            HLib_1.default.assert(node.type === NodeType_1.NodeType.NODE_ARRAY_ELEMENT, __filename + \":721\"); // インデクスがない定数アクセスはアドレスではありえない。\n            if (node.child) { // 変数インデクス\n                if (!this.generateExpression(node.child)) { // アドレスをプッシュ\n                    return false;\n                }\n            }\n            else {\n                this.addCommand('i', 0, '#絶対アドレスなので0\\n'); // 絶対アドレスアクセス\n            }\n            params.setStaticOffset(node.number);\n        }\n        return true;\n    };\n    FunctionGenerator.prototype.beginError = function (node) {\n        var token = node.token;\n        HLib_1.default.assert(token, __filename + \":737\");\n    };\n    return FunctionGenerator;\n}());\nexports.default = FunctionGenerator;\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/index.js\"))\n\n//# sourceURL=webpack:///./src/sunaba/FunctionGenerator.ts?");

/***/ }),

/***/ "./src/sunaba/FunctionInfo.ts":
/*!************************************!*\
  !*** ./src/sunaba/FunctionInfo.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FunctionInfo = /** @class */ (function () {\n    function FunctionInfo() {\n        this.mArgCount = 0;\n        this.mHasOutputValue = false;\n    }\n    FunctionInfo.prototype.setHasOutputValue = function () {\n        this.mHasOutputValue = true;\n    };\n    FunctionInfo.prototype.hasOutputValue = function () {\n        return this.mHasOutputValue;\n    };\n    FunctionInfo.prototype.argCount = function () {\n        return this.mArgCount;\n    };\n    FunctionInfo.prototype.setArgCount = function (a) {\n        this.mArgCount = a;\n    };\n    return FunctionInfo;\n}());\nexports.default = FunctionInfo;\n\n\n//# sourceURL=webpack:///./src/sunaba/FunctionInfo.ts?");

/***/ }),

/***/ "./src/sunaba/GraphicDevice.ts":
/*!*************************************!*\
  !*** ./src/sunaba/GraphicDevice.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar NullGraphicDevice = /** @class */ (function () {\n    function NullGraphicDevice() {\n    }\n    NullGraphicDevice.prototype.clear = function () {\n    };\n    NullGraphicDevice.prototype.write = function (addr, value) {\n    };\n    NullGraphicDevice.prototype.vsync = function () {\n    };\n    return NullGraphicDevice;\n}());\nexports.NullGraphicDevice = NullGraphicDevice;\n\n\n//# sourceURL=webpack:///./src/sunaba/GraphicDevice.ts?");

/***/ }),

/***/ "./src/sunaba/HLib.ts":
/*!****************************!*\
  !*** ./src/sunaba/HLib.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HLib = /** @class */ (function () {\n    function HLib() {\n    }\n    HLib.assert = function (f, mesg) {\n        if (mesg === void 0) { mesg = ''; }\n        if (f === false) {\n            throw new Error(\"BUG \" + mesg);\n        }\n    };\n    return HLib;\n}());\nexports.default = HLib;\n\n\n//# sourceURL=webpack:///./src/sunaba/HLib.ts?");

/***/ }),

/***/ "./src/sunaba/KeyboardDevice.ts":
/*!**************************************!*\
  !*** ./src/sunaba/KeyboardDevice.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar NullKeyboardDevice = /** @class */ (function () {\n    function NullKeyboardDevice() {\n    }\n    NullKeyboardDevice.prototype.isArrowLeftDowned = function () {\n        return false;\n    };\n    NullKeyboardDevice.prototype.isArrowUpKeyDowned = function () {\n        return false;\n    };\n    NullKeyboardDevice.prototype.isArrowDownDowned = function () {\n        return false;\n    };\n    NullKeyboardDevice.prototype.isArrowRightKeyDowned = function () {\n        return false;\n    };\n    NullKeyboardDevice.prototype.isSpaceKeyDowned = function () {\n        return false;\n    };\n    NullKeyboardDevice.prototype.isEnterKeyDowned = function () {\n        return false;\n    };\n    return NullKeyboardDevice;\n}());\nexports.NullKeyboardDevice = NullKeyboardDevice;\n\n\n//# sourceURL=webpack:///./src/sunaba/KeyboardDevice.ts?");

/***/ }),

/***/ "./src/sunaba/Machine.ts":
/*!*******************************!*\
  !*** ./src/sunaba/Machine.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MouseDevice_1 = __webpack_require__(/*! ./MouseDevice */ \"./src/sunaba/MouseDevice.ts\");\nvar KeyboardDevice_1 = __webpack_require__(/*! ./KeyboardDevice */ \"./src/sunaba/KeyboardDevice.ts\");\nvar CharacterDevice_1 = __webpack_require__(/*! ./CharacterDevice */ \"./src/sunaba/CharacterDevice.ts\");\nvar GraphicDevice_1 = __webpack_require__(/*! ./GraphicDevice */ \"./src/sunaba/GraphicDevice.ts\");\n// 設定定数。ただし、いじるとIOメモリの番号が変わるので、ソースコードが非互換になる。\nvar FREE_AND_PROGRAM_SIZE = 40000;\nvar STACK_SIZE = 10000;\nvar IO_MEMORY_SIZE = 10000;\nvar IO_WRITABLE_OFFSET = 5000;\nvar SCREEN_WIDTH = 100;\nvar SCREEN_HEIGHT = 100;\nvar MAX_CALL_COUNT = 256;\n// 自動計算定数類\nvar STACK_BASE = FREE_AND_PROGRAM_SIZE;\nvar STACK_END = STACK_BASE + STACK_SIZE;\nvar IO_BASE = STACK_END;\nvar IO_END = IO_BASE + IO_MEMORY_SIZE;\nvar IO_WRITABLE_BEGIN = IO_BASE + IO_WRITABLE_OFFSET;\nvar VRAM_BASE = IO_END;\nvar VRAM_SIZE = SCREEN_HEIGHT * SCREEN_WIDTH;\nvar Machine = /** @class */ (function () {\n    function Machine() {\n        this.waitSync = false;\n        this.isAutoSync = true;\n        this.VRAM_BASE = VRAM_BASE;\n        this.STACK_BASE = STACK_BASE;\n        this.program = [];\n        this.memory = [];\n        this.programCounter = 0;\n        this.stackPointer = STACK_BASE;\n        this.framePointer = 0;\n        this.clearMemory();\n        this.callCount = 0;\n        this.isRunning = false;\n        this.mouseDevice = new MouseDevice_1.NullMouseDevice();\n        this.keyboardDevice = new KeyboardDevice_1.NullKeyboardDevice();\n        this.characterDevice = new CharacterDevice_1.NullCharacterDevice();\n        this.graphicDevice = new GraphicDevice_1.NullGraphicDevice();\n    }\n    Machine.prototype.push = function (v) {\n        if (this.stackPointer >= STACK_END) {\n            throw new Error('E901: スタックを使い切った。名前つきメモリを使いすぎ。');\n        }\n        else {\n            this.memory[this.stackPointer] = v;\n            this.stackPointer += 1;\n        }\n    };\n    Machine.prototype.pop = function () {\n        if (this.stackPointer <= STACK_BASE) {\n            throw new Error('E902: ポップしすぎてスタック領域をはみ出した。');\n        }\n        else {\n            this.stackPointer -= 1;\n            return this.memory[this.stackPointer];\n        }\n    };\n    Machine.prototype.popN = function (n) {\n        if ((this.stackPointer - n) < STACK_BASE) {\n            throw new Error('E903: ポップしすぎてスタック領域をはみ出した。');\n        }\n        else if ((this.stackPointer - n) >= STACK_END) {\n            throw new Error('E904: スタックを使い切った。名前つきメモリを使いすぎ。');\n        }\n        else {\n            this.stackPointer -= n;\n        }\n    };\n    Machine.prototype.clearMemory = function () {\n        for (var i = 0; i < FREE_AND_PROGRAM_SIZE + STACK_SIZE + VRAM_SIZE; i += 1) {\n            this.memory[i] = 0;\n        }\n    };\n    Machine.prototype.loadProgram = function (program) {\n        this.clearMemory();\n        this.program = program;\n        this.programCounter = 0;\n        this.stackPointer = STACK_BASE;\n        this.framePointer = 0;\n        this.characterDevice.outMessage('プログラムを起動');\n        this.isRunning = true;\n    };\n    Machine.prototype.stop = function () {\n        if (this.isRunning) {\n            this.characterDevice.outMessage('プログラムを中止しました');\n        }\n        this.isRunning = false;\n    };\n    Machine.prototype.step = function () {\n        if (!this.isRunning) {\n            return;\n        }\n        try {\n            this.stepMain();\n        }\n        catch (e) {\n            this.characterDevice.outMessage(e.toString());\n            this.characterDevice.outMessage('エラーのため停止');\n            this.isRunning = false;\n        }\n    };\n    Machine.prototype.stepMain = function () {\n        if (!this.isRunning) {\n            return;\n        }\n        if (this.program.length <= this.programCounter) {\n            return;\n        }\n        var cmd = this.program[this.programCounter];\n        switch (cmd.name) {\n            case 'i':\n                this.step_i(cmd);\n                break;\n            case 'add':\n                this.step_add();\n                break;\n            case 'sub':\n                this.step_sub();\n                break;\n            case 'mul':\n                this.step_mul();\n                break;\n            case 'div':\n                this.step_div();\n                break;\n            case 'lt':\n                this.step_lt();\n                break;\n            case 'le':\n                this.step_le();\n                break;\n            case 'eq':\n                this.step_eq();\n                break;\n            case 'ne':\n                this.step_ne();\n                break;\n            case 'ld':\n            case 'fld':\n                this.step_ld(cmd);\n                break;\n            case 'st':\n            case 'fst':\n                this.step_st(cmd);\n                break;\n            case 'j':\n                this.step_j(cmd);\n                break;\n            case 'bz':\n                this.step_bz(cmd);\n                break;\n            case 'call':\n                this.step_call(cmd);\n                break;\n            case 'ret':\n                this.step_ret(cmd);\n                break;\n            case 'pop':\n                this.step_pop(cmd);\n                break;\n            default:\n                this.noop();\n                break;\n        }\n        if (this.program.length <= this.programCounter) {\n            this.isRunning = false;\n            this.characterDevice.outMessage('プログラムが最後まで実行された。');\n        }\n    };\n    Machine.prototype.noop = function () {\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_i = function (cmd) {\n        this.push(cmd.imm);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_add = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        var v = op0 + op1;\n        this.push(v);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_sub = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        var v = op0 - op1;\n        this.push(v);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_mul = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        var v = op0 * op1;\n        this.push(v);\n        this.programCounter += 1;\n    };\n    // E910\n    Machine.prototype.step_div = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        if (op1 === 0) {\n            throw new Error('E910: 0で割ろうとした。');\n        }\n        var v = Math.floor(op0 / op1);\n        this.push(v);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_lt = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        var v = op0 < op1 ? 1 : 0;\n        this.push(v);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_le = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        var v = op0 <= op1 ? 1 : 0;\n        this.push(v);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_eq = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        var v = op0 === op1 ? 1 : 0;\n        this.push(v);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_ne = function () {\n        var op1 = this.pop();\n        var op0 = this.pop();\n        var v = op0 !== op1 ? 1 : 0;\n        this.push(v);\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_ld = function (cmd) {\n        var op0 = this.pop_or_framepointer(cmd.name);\n        var addr = op0 + cmd.imm;\n        this.validate_read_address(addr);\n        var v = this.loadMemory(addr);\n        this.push(v);\n        this.programCounter += 1;\n    };\n    // E920\n    Machine.prototype.validate_read_address = function (addr) {\n        if (addr < 0) {\n            throw new Error(\"E920: \\u30DE\\u30A4\\u30CA\\u30B9\\u306E\\u756A\\u53F7\\u306E\\u30E1\\u30E2\\u30EA\\u3092\\u8AAD\\u307F\\u3068\\u308D\\u3046\\u3068\\u3057\\u305F(\\u756A\\u53F7:'\" + addr + \")\");\n        }\n        if (addr < STACK_BASE) {\n            // データ＋プログラム領域\n            // js版は、プログラムをメモリにロードしないので、この領域はすべてデータとして使える\n            // throw new Error(`E921: プログラムが入っているメモリを読みとろうとした(番号:${addr})`;\n            return;\n        }\n        if (addr < IO_BASE) {\n            // スタック領域\n            return;\n        }\n        if (addr < IO_WRITABLE_BEGIN) {\n            // IO_READ領域\n            return;\n        }\n        if (addr < VRAM_BASE) {\n            // IO_WRITE領域\n            throw new Error(\"E922: \\u3053\\u306E\\u3042\\u305F\\u308A\\u306E\\u30E1\\u30E2\\u30EA\\u306F\\u30BB\\u30C3\\u30C8\\u306F\\u3067\\u304D\\u308B\\u304C\\u8AAD\\u307F\\u53D6\\u308B\\u3053\\u3068\\u306F\\u3067\\u304D\\u306A\\u3044(\\u756A\\u53F7:\" + addr + \")\");\n        }\n        if (addr < VRAM_BASE + VRAM_SIZE) {\n            // VRAM領域\n            throw new Error(\"E923: \\u753B\\u9762\\u30E1\\u30E2\\u30EA\\u306F\\u8AAD\\u307F\\u53D6\\u308C\\u306A\\u3044(\\u756A\\u53F7:\" + addr + \")\");\n        }\n        throw new Error(\"E929: \\u30E1\\u30E2\\u30EA\\u7BC4\\u56F2\\u5916\\u3092\\u8AAD\\u307F\\u3068\\u308D\\u3046\\u3068\\u3057\\u305F(\\u756A\\u53F7:\" + addr + \")\");\n    };\n    Machine.prototype.pop_or_framepointer = function (cmd_name) {\n        var op;\n        switch (cmd_name) {\n            case 'ld':\n            case 'st':\n                op = this.pop();\n                break;\n            case 'fld':\n            case 'fst':\n                op = this.framePointer;\n                break;\n            default:\n                throw new Error(\"step_ld/step_st: unknown name: \" + cmd_name);\n        }\n        return op;\n    };\n    Machine.prototype.step_st = function (cmd) {\n        var op1 = this.pop();\n        var val = op1;\n        var op0 = this.pop_or_framepointer(cmd.name);\n        var addr = op0 + cmd.imm;\n        this.validate_write_address(addr, val);\n        this.setMemory(addr, val);\n        this.programCounter += 1;\n    };\n    // E930\n    Machine.prototype.validate_write_address = function (addr, value) {\n        if (addr < 0) {\n            throw new Error(\"E930: \\u30DE\\u30A4\\u30CA\\u30B9\\u306E\\u756A\\u53F7\\u306E\\u30E1\\u30E2\\u30EA\\u3092\\u5909\\u3048\\u3088\\u3046\\u3068\\u3057\\u305F(\\u756A\\u53F7:\" + addr + \",\\u5024:\" + value + \")\");\n        }\n        if (addr < STACK_BASE) {\n            // データ＋プログラム領域\n            // js版は、プログラムをメモリにロードしないので、この領域はすべてデータとして使える\n            // throw new Error(`E931: プログラムが入っているメモリにセットしようとした(番号:${addr},値:${value})`);\n            return;\n        }\n        if (addr < IO_BASE) {\n            // スタック領域\n            return;\n        }\n        if (addr < IO_WRITABLE_BEGIN) {\n            // IO_READ領域\n            throw new Error(\"E932: \\u3053\\u306E\\u3042\\u305F\\u308A\\u306E\\u30E1\\u30E2\\u30EA\\u306F\\u30BB\\u30C3\\u30C8\\u3067\\u304D\\u306A\\u3044(\\u756A\\u53F7:\" + addr + \",\\u5024:\" + value + \")\");\n        }\n        if (addr < VRAM_BASE) {\n            // IO_WRITE領域\n            return;\n        }\n        if (addr < VRAM_BASE + VRAM_SIZE) {\n            // VRAM領域\n            return;\n        }\n        throw new Error(\"E939: \\u30E1\\u30E2\\u30EA\\u7BC4\\u56F2\\u5916\\u3092\\u3044\\u3058\\u308D\\u3046\\u3068\\u3057\\u305F(\\u756A\\u53F7:\" + addr + \",\\u5024:\" + value + \")\");\n    };\n    Machine.prototype.step_j = function (cmd) {\n        this.programCounter = cmd.imm;\n    };\n    Machine.prototype.step_bz = function (cmd) {\n        var op0 = this.pop();\n        if (op0 === 0) {\n            this.programCounter = cmd.imm;\n        }\n        else {\n            this.programCounter += 1;\n        }\n    };\n    Machine.prototype.step_call = function (cmd) {\n        this.push(this.framePointer);\n        this.push(this.programCounter);\n        this.framePointer = this.stackPointer;\n        this.programCounter = cmd.imm;\n        this.callCount += 1;\n        if (MAX_CALL_COUNT <= this.callCount) {\n            throw new Error(\"\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u3092\\u6FC0\\u3057\\u304F\\u547C\\u3073\\u3059\\u304E\\u3002\\u305F\\u3076\\u3093\\u518D\\u5E30\\u306B\\u9593\\u9055\\u3044\\u304C\\u3042\\u308B(\\u547D\\u4EE4:\" + this.programCounter + \")\");\n        }\n    };\n    Machine.prototype.step_ret = function (cmd) {\n        this.popN(cmd.imm);\n        this.programCounter = this.pop();\n        this.framePointer = this.pop();\n        this.callCount -= 1;\n        if (this.callCount < 0) {\n            throw new Error(\"ret\\u547D\\u4EE4\\u304C\\u591A\\u3059\\u304E\\u3066\\u3044\\u308B\\u3002\\u7D76\\u5BFE\\u304A\\u304B\\u3057\\u3044(\\u547D\\u4EE4:\" + this.programCounter + \")\");\n        }\n        this.programCounter += 1;\n    };\n    Machine.prototype.step_pop = function (cmd) {\n        this.popN(cmd.imm);\n        this.programCounter += 1;\n    };\n    Machine.prototype.getStack = function () {\n        var stack = [];\n        for (var i = 0; i < this.stackPointer - STACK_BASE; i += 1) {\n            stack[i] = this.memory[STACK_BASE + i];\n        }\n        return stack;\n    };\n    Machine.prototype.setMemory = function (address, value) {\n        this.memory[address] = value;\n        if (VRAM_BASE <= address) {\n            this.graphicDevice.write(address - VRAM_BASE, value);\n        }\n        else {\n            switch (address) {\n                case 55000:\n                    this.waitSync = true;\n                    break;\n                case 55001:\n                    this.isAutoSync = !value;\n                    break;\n                case 55002:\n                    this.characterDevice.outDebug(value);\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n    Machine.prototype.loadMemory = function (address) {\n        switch (address) {\n            case 50000:\n                return this.mouseDevice.getPosX();\n            case 50001:\n                return this.mouseDevice.getPosY();\n            case 50002:\n                return this.mouseDevice.isLeftButtonDowned() ? 1 : 0;\n            case 50003:\n                return this.mouseDevice.isRightButtonDowned() ? 1 : 0;\n            case 50004:\n                return this.keyboardDevice.isArrowUpKeyDowned() ? 1 : 0;\n            case 50005:\n                return this.keyboardDevice.isArrowDownDowned() ? 1 : 0;\n            case 50006:\n                return this.keyboardDevice.isArrowLeftDowned() ? 1 : 0;\n            case 50007:\n                return this.keyboardDevice.isArrowRightKeyDowned() ? 1 : 0;\n            case 50008:\n                return this.keyboardDevice.isSpaceKeyDowned() ? 1 : 0;\n            case 50009:\n                return this.keyboardDevice.isEnterKeyDowned() ? 1 : 0;\n            default:\n                break;\n        }\n        return this.memory[address];\n    };\n    Machine.prototype.getProgramCounter = function () {\n        return this.programCounter;\n    };\n    Machine.prototype.getStackPointer = function () {\n        return this.stackPointer;\n    };\n    Machine.prototype.getFramePointer = function () {\n        return this.framePointer;\n    };\n    Machine.prototype.setFramePointer = function (value) {\n        this.framePointer = value;\n    };\n    Machine.prototype.setMouseDevice = function (mouseDevice) {\n        this.mouseDevice = mouseDevice;\n    };\n    Machine.prototype.setKeyboardDevice = function (keyboardDevice) {\n        this.keyboardDevice = keyboardDevice;\n    };\n    Machine.prototype.setCharacterDevice = function (characterDevice) {\n        this.characterDevice = characterDevice;\n    };\n    Machine.prototype.setGraphicDevice = function (graphicDevice) {\n        this.graphicDevice = graphicDevice;\n    };\n    Machine.prototype.runSingleFrame = function (maxTimeMilliSeconds, maxStepCount) {\n        var t0_ms = (new Date()).getTime();\n        for (var i = 0; i < maxStepCount; i += 1) {\n            this.step();\n            if (this.waitSync) {\n                break;\n            }\n            var t1_ms = (new Date()).getTime();\n            var dt_ms = t1_ms - t0_ms;\n            if (maxTimeMilliSeconds <= dt_ms) {\n                break;\n            }\n        }\n        if (this.isAutoSync || this.waitSync) {\n            this.graphicDevice.vsync();\n            this.waitSync = false;\n        }\n    };\n    return Machine;\n}());\nexports.default = Machine;\n\n\n//# sourceURL=webpack:///./src/sunaba/Machine.ts?");

/***/ }),

/***/ "./src/sunaba/MouseDevice.ts":
/*!***********************************!*\
  !*** ./src/sunaba/MouseDevice.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar NullMouseDevice = /** @class */ (function () {\n    function NullMouseDevice() {\n    }\n    NullMouseDevice.prototype.getPosX = function () {\n        return 0;\n    };\n    NullMouseDevice.prototype.getPosY = function () {\n        return 0;\n    };\n    NullMouseDevice.prototype.isLeftButtonDowned = function () {\n        return false;\n    };\n    NullMouseDevice.prototype.isRightButtonDowned = function () {\n        return false;\n    };\n    return NullMouseDevice;\n}());\nexports.NullMouseDevice = NullMouseDevice;\n\n\n//# sourceURL=webpack:///./src/sunaba/MouseDevice.ts?");

/***/ }),

/***/ "./src/sunaba/Node.ts":
/*!****************************!*\
  !*** ./src/sunaba/Node.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint no-unused-vars: 0 */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TokenType_1 = __importDefault(__webpack_require__(/*! ./TokenType */ \"./src/sunaba/TokenType.ts\"));\nvar NodeType_1 = __webpack_require__(/*! ./NodeType */ \"./src/sunaba/NodeType.ts\");\nvar Node = /** @class */ (function () {\n    function Node(type, token, child, brother) {\n        if (token === void 0) { token = null; }\n        if (child === void 0) { child = null; }\n        if (brother === void 0) { brother = null; }\n        this.type = type;\n        this.token = token;\n        this.child = child;\n        this.brother = brother;\n        this.operator = '';\n        this.number = 0;\n        this.negation = false;\n    }\n    Node.createExpression = function (token, operator, child, brother) {\n        var node = new Node(NodeType_1.NodeType.NODE_EXPRESSION);\n        node.token = token;\n        node.operator = operator;\n        node.child = child;\n        node.brother = brother;\n        return node;\n    };\n    Node.createNumber = function (token, number, child, brother) {\n        var node = new Node(NodeType_1.NodeType.NODE_NUMBER);\n        node.token = token;\n        node.number = number || 0;\n        node.child = child;\n        node.brother = brother;\n        return node;\n    };\n    Node.prototype.isOutputValueSubstitution = function () {\n        if (this.token === null) {\n            return false;\n        }\n        return this.token.type === TokenType_1.default.TOKEN_OUT;\n    };\n    return Node;\n}());\nexports.default = Node;\n\n\n//# sourceURL=webpack:///./src/sunaba/Node.ts?");

/***/ }),

/***/ "./src/sunaba/NodeType.ts":
/*!********************************!*\
  !*** ./src/sunaba/NodeType.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint no-unused-vars: 0 */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TermType;\n(function (TermType) {\n    TermType[TermType[\"TERM_EXPRESSION\"] = 0] = \"TERM_EXPRESSION\";\n    TermType[TermType[\"TERM_NUMBER\"] = 1] = \"TERM_NUMBER\";\n    TermType[TermType[\"TERM_FUNCTION\"] = 2] = \"TERM_FUNCTION\";\n    TermType[TermType[\"TERM_ARRAY_ELEMENT\"] = 3] = \"TERM_ARRAY_ELEMENT\";\n    TermType[TermType[\"TERM_VARIABLE\"] = 4] = \"TERM_VARIABLE\";\n    TermType[TermType[\"TERM_OUT\"] = 5] = \"TERM_OUT\";\n    TermType[TermType[\"TERM_UNKNOWN\"] = 99] = \"TERM_UNKNOWN\";\n})(TermType = exports.TermType || (exports.TermType = {}));\nvar StatementType;\n(function (StatementType) {\n    StatementType[StatementType[\"STATEMENT_WHILE_OR_IF\"] = 0] = \"STATEMENT_WHILE_OR_IF\";\n    StatementType[StatementType[\"STATEMENT_DEF\"] = 1] = \"STATEMENT_DEF\";\n    StatementType[StatementType[\"STATEMENT_CONST\"] = 2] = \"STATEMENT_CONST\";\n    StatementType[StatementType[\"STATEMENT_FUNCTION\"] = 3] = \"STATEMENT_FUNCTION\";\n    StatementType[StatementType[\"STATEMENT_SUBSTITUTION\"] = 4] = \"STATEMENT_SUBSTITUTION\";\n    StatementType[StatementType[\"STATEMENT_UNKNOWN\"] = 99] = \"STATEMENT_UNKNOWN\";\n})(StatementType = exports.StatementType || (exports.StatementType = {}));\nvar NodeType;\n(function (NodeType) {\n    // test/fixture/??_vmcode.json に記述しているので、値を固定した\n    NodeType[NodeType[\"NODE_PROGRAM\"] = 0] = \"NODE_PROGRAM\";\n    NodeType[NodeType[\"NODE_WHILE_STATEMENT\"] = 1] = \"NODE_WHILE_STATEMENT\";\n    NodeType[NodeType[\"NODE_IF_STATEMENT\"] = 2] = \"NODE_IF_STATEMENT\";\n    NodeType[NodeType[\"NODE_SUBSTITUTION_STATEMENT\"] = 3] = \"NODE_SUBSTITUTION_STATEMENT\";\n    NodeType[NodeType[\"NODE_FUNCTION_DEFINITION\"] = 4] = \"NODE_FUNCTION_DEFINITION\";\n    NodeType[NodeType[\"NODE_EXPRESSION\"] = 5] = \"NODE_EXPRESSION\";\n    NodeType[NodeType[\"NODE_VARIABLE\"] = 6] = \"NODE_VARIABLE\";\n    NodeType[NodeType[\"NODE_NUMBER\"] = 7] = \"NODE_NUMBER\";\n    NodeType[NodeType[\"NODE_OUT\"] = 8] = \"NODE_OUT\";\n    NodeType[NodeType[\"NODE_ARRAY_ELEMENT\"] = 9] = \"NODE_ARRAY_ELEMENT\";\n    NodeType[NodeType[\"NODE_FUNCTION\"] = 10] = \"NODE_FUNCTION\";\n    NodeType[NodeType[\"NODE_UNKNOWN\"] = 99] = \"NODE_UNKNOWN\";\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\n\n\n//# sourceURL=webpack:///./src/sunaba/NodeType.ts?");

/***/ }),

/***/ "./src/sunaba/Parser.ts":
/*!******************************!*\
  !*** ./src/sunaba/Parser.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__filename) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint\n    no-unused-vars: 0\n*/\nvar HLib_1 = __importDefault(__webpack_require__(/*! ./HLib */ \"./src/sunaba/HLib.ts\"));\nvar TokenType_1 = __importDefault(__webpack_require__(/*! ./TokenType */ \"./src/sunaba/TokenType.ts\"));\nvar NodeType_1 = __webpack_require__(/*! ./NodeType */ \"./src/sunaba/NodeType.ts\");\nvar Node_1 = __importDefault(__webpack_require__(/*! ./Node */ \"./src/sunaba/Node.ts\"));\nvar Parser = /** @class */ (function () {\n    function Parser(tokens, locale) {\n        this.errorMessage = '';\n        this.mTokens = tokens;\n        this.mLocale = locale;\n        this.mConstMap = {};\n        this.mPos = 0;\n    }\n    // Program : (Const | FuncDef | Statement )*\n    Parser.prototype.parseProgram = function () {\n        // 定数マップに「メモリ」と「memory」を登録\n        this.mConstMap.memory = 0;\n        var memoryWord = this.mLocale.memoryWord;\n        this.mConstMap[memoryWord] = 0;\n        // Programノードを確保\n        // let node:Node = {type:'PROGRAM', child:null, brother:null};\n        var node = new Node_1.default(NodeType_1.NodeType.NODE_PROGRAM);\n        // 定数全て処理\n        // このループを消して、後ろのループのparseConstのtrueを消せば、定数定義を前に限定できる\n        var tokens = this.mTokens;\n        this.mPos = 0;\n        while (tokens[this.mPos].type !== TokenType_1.default.TOKEN_END) {\n            var t = tokens[this.mPos];\n            if (t.type === TokenType_1.default.TOKEN_CONST) {\n                if (!this.parseConst(false)) { // ノードを返さない。\n                    return null;\n                }\n            }\n            else {\n                this.mPos += 1;\n            }\n        }\n        // 残りを処理\n        this.mPos = 0;\n        var lastChild = null;\n        while (tokens[this.mPos].type !== TokenType_1.default.TOKEN_END) {\n            var statementType = this.getStatementType();\n            var child = null;\n            if (statementType === null) {\n                return null;\n            }\n            if (statementType === NodeType_1.StatementType.STATEMENT_CONST) { // 定数は処理済みなのでスキップ\n                if (!this.parseConst(true)) {\n                    return null;\n                }\n            }\n            else {\n                if (statementType === NodeType_1.StatementType.STATEMENT_DEF) {\n                    child = this.parseFunctionDefinition();\n                }\n                else {\n                    child = this.parseStatement();\n                }\n                if (child === null) {\n                    return null;\n                }\n                if (!lastChild) {\n                    node.child = child;\n                }\n                else {\n                    lastChild.brother = child;\n                }\n                lastChild = child;\n            }\n        }\n        return node;\n    };\n    // Const : const name -> expression;\n    // ノードを生成しないので、boolを返す。\n    Parser.prototype.parseConst = function (skipFlag) {\n        var tokens = this.mTokens;\n        var t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_CONST) {\n            throw new Error('E101: 定数行のはずだが解釈できない。上の行からつながってないか。');\n        }\n        HLib_1.default.assert(t.type === TokenType_1.default.TOKEN_CONST, __filename + \":91\");\n        this.mPos += 1;\n        // 名前\n        t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_NAME) {\n            throw new Error(\"E102: \\u884C\" + t.line + \": \\u5B9A\\u6570'\\u306E\\u6B21\\u306F\\u5B9A\\u6570\\u540D\\u3002'\" + t.string + \"'\\u306F\\u5B9A\\u6570\\u540D\\u3068\\u89E3\\u91C8\\u3067\\u304D\\u306A\\u3044\\u3002\");\n        }\n        var constName = t.string || '';\n        this.mPos += 1;\n        // →\n        t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_SUBSTITUTION) {\n            throw new Error(\"E103: \\u884C\" + t.line + \": \\u5B9A\\u6570 [\\u540D\\u524D]\\u3001\\u3068\\u6765\\u305F\\u3089\\u6B21\\u306F'\\u2192'\\u306E\\u306F\\u305A\\u3060\\u304C\\u300C\" + t.string + \"'\\u300D\\u304C\\u3042\\u308B\\u3002\");\n        }\n        this.mPos += 1;\n        // Expression\n        var expression = this.parseExpression();\n        if (expression === null) {\n            return false;\n        }\n        if (expression.type !== NodeType_1.NodeType.NODE_NUMBER) { // 数字に解決されていなければ駄目。\n            throw new Error(\"E104: \\u884C\" + t.line + \": \\u5B9A\\u6570\\u306E\\u53F3\\u8FBA\\u306E\\u8A08\\u7B97\\u306B\\u5931\\u6557\\u3057\\u305F\\u3002\\u30E1\\u30E2\\u30EA\\u3084\\u540D\\u524D\\u3064\\u304D\\u30E1\\u30E2\\u30EA\\u3001\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u53C2\\u7167\\u306A\\u3069\\u304C\\u5165\\u3063\\u3066\\u3044\\u306A\\u3044\\u304B\\uFF1F\");\n        }\n        var constValue = expression.number;\n        // this.mPos += 1; // C#版は += 1していないのでコメント化した\n        // 文末\n        t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_STATEMENT_END) {\n            throw new Error(\"\\u884C\" + t.line + \": \\u5B9A\\u6570\\u4F5C\\u6210\\u306E\\u5F8C\\u306B'\" + t.string + \"'\\u304C\\u3042\\u308B\\u3002\\u6539\\u884C\\u3057\\u3066\\u304F\\u308C\\u3002\\n\");\n        }\n        this.mPos += 1;\n        // マップに登録\n        if (!skipFlag) {\n            if (constName in this.mConstMap) { // もうある\n                throw new Error(\"E105: \\u884C\" + t.line + \": \\u5B9A\\u6570\\u300C\" + constName + \"\\u300D\\u306F\\u3059\\u3067\\u306B\\u540C\\u3058\\u540D\\u524D\\u306E\\u5B9A\\u6570\\u304C\\u3042\\u308B\\u3002\");\n            }\n            this.mConstMap[constName] = constValue;\n        }\n        return true;\n    };\n    // FunctionDefinition : name ( name? [ , name ]* ) とは [{ statement* }]\n    // FunctionDefinition : def name ( name? [ , name ]* ) [{ statement* }]\n    Parser.prototype.parseFunctionDefinition = function () {\n        // defスキップ\n        var tokens = this.mTokens;\n        var t = tokens[this.mPos];\n        var defFound = false;\n        if (t.type === TokenType_1.default.TOKEN_DEF_PRE) {\n            this.mPos += 1;\n            defFound = true;\n            t = tokens[this.mPos];\n        }\n        // ノード準備\n        var node = new Node_1.default(NodeType_1.NodeType.NODE_FUNCTION_DEFINITION, t);\n        this.mPos += 1;\n        // (\n        t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_LEFT_BRACKET) {\n            throw new Error(\"E110: \\u884C\" + t.line + \": \\u5165\\u529B\\u30EA\\u30B9\\u30C8\\u958B\\u59CB\\u306E\\u300C(\\u300D\\u304C\\u3042\\u308B\\u306F\\u305A\\u3060\\u304C\\u3001\\u300C\" + t.string + \"\\u300D\\u304C\\u3042\\u308B\\u3002\");\n        }\n        this.mPos += 1;\n        // 次がnameなら引数が一つはある\n        var lastChild = null;\n        t = tokens[this.mPos];\n        if (t.type === TokenType_1.default.TOKEN_NAME) {\n            var arg = this.parseVariable();\n            if (arg === null) {\n                return null;\n            }\n            node.child = arg;\n            lastChild = arg;\n            // 第二引数以降を処理\n            while (tokens[this.mPos].type === TokenType_1.default.TOKEN_COMMA) {\n                this.mPos += 1;\n                t = tokens[this.mPos];\n                if (t.type !== TokenType_1.default.TOKEN_NAME) { // 名前でないのはエラー\n                    throw new Error(\"E111: \\u884C\" + t.line + \": \\u5165\\u529B\\u30EA\\u30B9\\u30C8\\u4E2D\\u306B\\u300C,\\u300D\\u304C\\u3042\\u308B\\u4EE5\\u4E0A\\u3001\\u307E\\u3060\\u5165\\u529B\\u304C\\u3042\\u308B\\u306F\\u305A\\u3060\\u304C\\u3001\\u300C\" + t.string + \"\\u300D\\u304C\\u3042\\u308B\\u3002\");\n                }\n                arg = this.parseVariable();\n                if (arg === null) {\n                    return null;\n                }\n                // 引数名が定数なのは許さない\n                t = tokens[this.mPos];\n                if (arg.type === NodeType_1.NodeType.NODE_NUMBER) { // 定数は構文解析中に解決されてNUMBERになってしまう。\n                    throw new Error(\"E112: \\u884C\" + t.line + \": \\u5B9A\\u6570\\u3068\\u540C\\u3058\\u540D\\u524D\\u306F\\u5165\\u529B\\u306B\\u3064\\u3051\\u3089\\u308C\\u306A\\u3044\\u3002\");\n                }\n                lastChild.brother = arg;\n                lastChild = arg;\n            }\n        }\n        // )\n        t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_RIGHT_BRACKET) {\n            throw new Error(\"E113: \\u884C\" + t.line + \": \\u5165\\u529B\\u30EA\\u30B9\\u30C8\\u7D42\\u4E86\\u306E\\u300C)\\u300D\\u304C\\u3042\\u308B\\u306F\\u305A\\u3060\\u304C\\u3001\\u300C\" + t.string + \"\\u300D\\u304C\\u3042\\u308B\\u3002\");\n        }\n        this.mPos += 1;\n        // とは\n        t = tokens[this.mPos];\n        if (t.type === TokenType_1.default.TOKEN_DEF_POST) {\n            if (defFound) {\n                throw new Error(\"E114: \\u884C\" + t.line + \": \\u300Cdef\\u300D\\u3068\\u300C\\u3068\\u306F\\u300D\\u304C\\u4E21\\u65B9\\u3042\\u308B\\u3002\\u7247\\u65B9\\u306B\\u3057\\u3066\\u307B\\u3057\\u3044\\u3002\");\n            }\n            defFound = true;\n            this.mPos += 1;\n        }\n        // 関数定義の中身\n        t = tokens[this.mPos];\n        if (t.type === TokenType_1.default.TOKEN_BLOCK_BEGIN) {\n            this.mPos += 1;\n            for (t = tokens[this.mPos];; t = tokens[this.mPos]) {\n                var child = null;\n                if (t.type === TokenType_1.default.TOKEN_BLOCK_END) { // 終わり\n                    this.mPos += 1;\n                    break;\n                }\n                else if (t.type === TokenType_1.default.TOKEN_CONST) { // 定数は関数定義の中では許しませんよ\n                    throw new Error(\"E115: \\u884C\" + t.line + \": \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u5185\\u3067\\u5B9A\\u6570\\u306F\\u4F5C\\u308C\\u306A\\u3044\\u3002\");\n                }\n                else {\n                    child = this.parseStatement();\n                    if (child === null) {\n                        return null;\n                    }\n                }\n                if (lastChild !== null) {\n                    lastChild.brother = child;\n                }\n                else {\n                    node.child = child;\n                }\n                lastChild = child;\n            }\n        }\n        else if (t.type === TokenType_1.default.TOKEN_STATEMENT_END) { // いきなり空\n            this.mPos += 1;\n        }\n        else { // エラー\n            throw new Error(\"E116: \\u884C\" + t.line + \": \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u306E\\u6700\\u521D\\u306E\\u884C\\u306E\\u884C\\u672B\\u306B\\u300C\" + t.string + \"\\u300D\\u304C\\u7D9A\\u3044\\u3066\\u3044\\u308B\\u3002\\u6539\\u884C\\u3057\\u3088\\u3046\\u3002\");\n        }\n        return node;\n    };\n    // Statement : ( while | if | return | funcDef | func | set )\n    Parser.prototype.parseStatement = function () {\n        var statementType = this.getStatementType();\n        var node = null;\n        var t = null;\n        if (statementType === NodeType_1.StatementType.STATEMENT_WHILE_OR_IF) {\n            node = this.parseWhileOrIfStatement();\n        }\n        else if (statementType === NodeType_1.StatementType.STATEMENT_DEF) { // これはエラー\n            t = this.mTokens[this.mPos];\n            throw new Error(\"E120: \\u884C\" + t.line + \": \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u5185\\u3067\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u306F\\u4F5C\\u308C\\u306A\\u3044\\u3002\");\n        }\n        else if (statementType === NodeType_1.StatementType.STATEMENT_CONST) { // これはありえない\n            throw new Error('BUG parseStatement CONST');\n        }\n        else if (statementType === NodeType_1.StatementType.STATEMENT_FUNCTION) { // 関数呼び出し文\n            node = this.parseFunction();\n            if (node === null) {\n                return null;\n            }\n            t = this.mTokens[this.mPos];\n            if (t.type !== TokenType_1.default.TOKEN_STATEMENT_END) { // 文終わってないぞ\n                if (t.type === TokenType_1.default.TOKEN_BLOCK_BEGIN) {\n                    throw new Error(\"E121: \\u884C\" + t.line + \": \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u3092\\u4F5C\\u308D\\u3046\\u3068\\u3057\\u305F\\uFF1F\\u305D\\u308C\\u306F\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u306E\\u5916\\u3067\\u300Cdef\\u300D\\u306A\\u308A\\u300C\\u3068\\u306F\\u300D\\u306A\\u308A\\u3092\\u4F7F\\u3063\\u3066\\u306D\\u3002\\u305D\\u308C\\u3068\\u3082\\u3001\\u6B21\\u306E\\u884C\\u306E\\u5B57\\u4E0B\\u3052\\u304C\\u591A\\u3059\\u304E\\u305F\\u3060\\u3051\\uFF1F\");\n                }\n                else {\n                    throw new Error(\"E122: \\u884C\" + t.line + \": \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u53C2\\u7167\\u306E\\u5F8C\\u308D\\u306B\\u3001\\u300C\" + t.string + \"\\u300D\\u304C\\u3042\\u308B\\u3002\\u6539\\u884C\\u3057\\u305F\\u3089\\uFF1F\");\n                }\n            }\n            this.mPos += 1;\n        }\n        else if (statementType === NodeType_1.StatementType.STATEMENT_SUBSTITUTION) { // 代入\n            node = this.parseSubstitutionStatement();\n        }\n        else if (statementType === NodeType_1.StatementType.STATEMENT_UNKNOWN) { // 不明。エラー文字列は作ってあるので上へ\n            return null;\n        }\n        else {\n            throw new Error('BUG parseStatement');\n        }\n        return node;\n    };\n    // 文タイプを判定\n    // DEF, FUNC, WHILE_OR_IF, CONST, SET, nullのどれかが返る。メンバは変更しない。\n    Parser.prototype.getStatementType = function () {\n        var pos = this.mPos; // コピーを作ってこっちをいじる。オブジェクトの状態は変えない。\n        var tokens = this.mTokens;\n        var t = tokens[pos];\n        // 文頭でわかるケースを判別\n        if (t.type === TokenType_1.default.TOKEN_BLOCK_BEGIN) {\n            throw new Error(\"E130: \\u884C\" + t.line + \": \\u5B57\\u4E0B\\u3052\\u3092\\u9593\\u9055\\u3063\\u3066\\u3044\\u308B\\u306F\\u305A\\u3002\\u4E0A\\u306E\\u884C\\u3088\\u308A\\u591A\\u304F\\u306A\\u3044\\u304B\\u3002\");\n        }\n        else if ((t.type === TokenType_1.default.TOKEN_WHILE_PRE) || (t.type === TokenType_1.default.TOKEN_IF_PRE)) {\n            return NodeType_1.StatementType.STATEMENT_WHILE_OR_IF;\n        }\n        else if (t.type === TokenType_1.default.TOKEN_DEF_PRE) {\n            return NodeType_1.StatementType.STATEMENT_DEF;\n        }\n        else if (t.type === TokenType_1.default.TOKEN_CONST) {\n            return NodeType_1.StatementType.STATEMENT_CONST;\n        }\n        // 文末までスキャン\n        var endPos = pos;\n        while ((tokens[endPos].type !== TokenType_1.default.TOKEN_STATEMENT_END) && (tokens[endPos].type !== TokenType_1.default.TOKEN_BLOCK_BEGIN)) {\n            endPos += 1;\n        }\n        // 後置キーワード判定\n        if (endPos > pos) {\n            t = tokens[endPos - 1];\n            if ((t.type === TokenType_1.default.TOKEN_WHILE_POST) || (t.type === TokenType_1.default.TOKEN_IF_POST)) {\n                return NodeType_1.StatementType.STATEMENT_WHILE_OR_IF;\n            }\n            if (t.type === TokenType_1.default.TOKEN_DEF_POST) {\n                return NodeType_1.StatementType.STATEMENT_DEF;\n            }\n        }\n        // 代入記号を探す\n        for (var i = pos; i < endPos; i += 1) {\n            if (tokens[i].type === TokenType_1.default.TOKEN_SUBSTITUTION) {\n                return NodeType_1.StatementType.STATEMENT_SUBSTITUTION;\n            }\n        }\n        // 残るは関数コール文?\n        if ((tokens[pos].type === TokenType_1.default.TOKEN_NAME) && (tokens[pos + 1].type === TokenType_1.default.TOKEN_LEFT_BRACKET)) {\n            return NodeType_1.StatementType.STATEMENT_FUNCTION;\n        }\n        // 解釈不能。ありがちなのは「なかぎり」「なら」の左に空白がないケース\n        throw new Error(\"E131: \\u884C\" + t.line + \": \\u89E3\\u91C8\\u3067\\u304D\\u306A\\u3044\\u3002\\u6CE8\\u91C8\\u306F// \\u3058\\u3083\\u306A\\u304F\\u3066#\\u3060\\u3088\\uFF1F\\u3042\\u3068\\u3001\\u300C\\u306A\\u304B\\u304E\\u308A\\u300D\\u300C\\u306A\\u3089\\u300D\\u306E\\u524D\\u306B\\u306F\\u7A7A\\u767D\\u3042\\u308B\\uFF1F\\u305D\\u308C\\u3068\\u3001\\u30E1\\u30E2\\u30EA\\u30BB\\u30C3\\u30C8\\u306F=\\u3058\\u3083\\u306A\\u304F\\u3066\\u2192\\u3060\\u3088\\uFF1F\");\n        // TODO: どんなエラーか推測してやれ\n        // TODO: 後ろにゴミがあるくらいなら無視して進む手もあるが、要検討\n    };\n    // Set: [out | memory | name | array] → expression ;\n    Parser.prototype.parseSubstitutionStatement = function () {\n        //\n        var tokens = this.mTokens;\n        var t = tokens[this.mPos];\n        if ((t.type !== TokenType_1.default.TOKEN_NAME) && (t.type !== TokenType_1.default.TOKEN_OUT)) {\n            throw new Error(\"E140: \\u884C\" + t.line + \": \\u300C\\u2192\\u300D\\u304C\\u3042\\u308B\\u306E\\u3067\\u30E1\\u30E2\\u30EA\\u30BB\\u30C3\\u30C8\\u884C\\u3060\\u3068\\u601D\\u3046\\u304C\\u3001\\u305D\\u308C\\u306A\\u3089\\u300Cmemory\\u300D\\u3068\\u304B\\u300Cout\\u300D\\u3068\\u304B\\u3001\\u540D\\u524D\\u4ED8\\u304D\\u30E1\\u30E2\\u30EA\\u306E\\u540D\\u524D\\u3068\\u304B\\u3001\\u305D\\u3046\\u3044\\u3046\\u3082\\u306E\\u304B\\u3089\\u59CB\\u307E\\u308B\\u306F\\u305A\\u3002\");\n        }\n        var node = new Node_1.default(NodeType_1.NodeType.NODE_SUBSTITUTION_STATEMENT, t);\n        // 左辺\n        var left = null;\n        if (t.type === TokenType_1.default.TOKEN_OUT) {\n            left = new Node_1.default(NodeType_1.NodeType.NODE_OUT, t);\n            this.mPos += 1;\n        }\n        else if (tokens[this.mPos + 1].type === TokenType_1.default.TOKEN_INDEX_BEGIN) {\n            // 配列だ\n            left = this.parseArrayElement();\n        }\n        else { // 変数\n            left = this.parseVariable();\n            if (left.type === NodeType_1.NodeType.NODE_NUMBER) {\n                // 定数じゃん！\n                throw new Error(\"E141: \\u884C\" + t.line + \": \" + t.string + \"\\u306F\\u5B9A\\u6570\\u3067\\u3001\\u30BB\\u30C3\\u30C8\\u3067\\u304D\\u306A\\u3044\\u3002\");\n            }\n        }\n        if (left === null) {\n            return null;\n        }\n        node.child = left;\n        // →\n        t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_SUBSTITUTION) {\n            throw new Error(\"E142: \\u884C\" + t.line + \": \\u30E1\\u30E2\\u30EA\\u30BB\\u30C3\\u30C8\\u884C\\u3060\\u3068\\u601D\\u3063\\u305F\\u306E\\u3060\\u304C\\u3001\\u3042\\u308B\\u3079\\u304D\\u5834\\u6240\\u306B\\u300C\\u2192\\u300D\\u304C\\u306A\\u3044\\u3002\");\n        }\n        this.mPos += 1;\n        // 右辺は式\n        var right = this.parseExpression();\n        if (right === null) {\n            return null;\n        }\n        left.brother = right;\n        // ;\n        t = tokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_STATEMENT_END) {\n            throw new Error(\"E143: \\u884C\" + t.line + \": \\u6B21\\u306E\\u884C\\u306E\\u5B57\\u4E0B\\u3052\\u304C\\u591A\\u3059\\u304E\\u308B\\u3093\\u3058\\u3083\\u306A\\u304B\\u308D\\u3046\\u304B\\u3002\");\n        }\n        this.mPos += 1;\n        return node;\n    };\n    // while|if expression [ { } ]\n    // while|if expression;\n    // expression while_post|if_post [ { } ]\n    // expression while_post|if_post ;\n    Parser.prototype.parseWhileOrIfStatement = function () {\n        var tokens = this.mTokens;\n        var t = tokens[this.mPos];\n        var node = new Node_1.default(NodeType_1.NodeType.NODE_UNKNOWN, t);\n        // 前置ならすぐ決まる\n        if (t.type === TokenType_1.default.TOKEN_WHILE_PRE) {\n            node.type = NodeType_1.NodeType.NODE_WHILE_STATEMENT;\n            this.mPos += 1;\n        }\n        else if (t.type === TokenType_1.default.TOKEN_IF_PRE) {\n            node.type = NodeType_1.NodeType.NODE_IF_STATEMENT;\n            this.mPos += 1;\n        }\n        // 条件式\n        var exp = this.parseExpression();\n        if (exp === null) {\n            return null;\n        }\n        node.child = exp;\n        // まだどっちか確定してない場合、ここにキーワードがあるはず\n        t = tokens[this.mPos];\n        if (node.type === NodeType_1.NodeType.NODE_UNKNOWN) {\n            if (t.type === TokenType_1.default.TOKEN_WHILE_POST) {\n                node.type = NodeType_1.NodeType.NODE_WHILE_STATEMENT;\n            }\n            else if (t.type === TokenType_1.default.TOKEN_IF_POST) {\n                node.type = NodeType_1.NodeType.NODE_IF_STATEMENT;\n            }\n            this.mPos += 1;\n        }\n        // ブロックがあるなら処理\n        t = tokens[this.mPos];\n        if (t.type === TokenType_1.default.TOKEN_BLOCK_BEGIN) {\n            this.mPos += 1;\n            var lastChild = exp;\n            for (;;) {\n                var child = null;\n                t = tokens[this.mPos];\n                if (t.type === TokenType_1.default.TOKEN_BLOCK_END) {\n                    this.mPos += 1;\n                    break;\n                }\n                else if (t.type === TokenType_1.default.TOKEN_CONST) {\n                    throw new Error(\"E150: \\u884C\" + t.line + \": \\u7E70\\u308A\\u8FD4\\u3057\\u3084\\u6761\\u4EF6\\u5B9F\\u884C\\u306E\\u4E2D\\u3067\\u5B9A\\u6570\\u306F\\u4F5C\\u308C\\u306A\\u3044\\u3002\");\n                }\n                else {\n                    child = this.parseStatement();\n                }\n                if (child === null) {\n                    return null;\n                }\n                lastChild.brother = child;\n                lastChild = child;\n            }\n        }\n        else if (t.type === TokenType_1.default.TOKEN_STATEMENT_END) { // 中身なしwhile/if\n            this.mPos += 1;\n        }\n        else {\n            throw new Error(\"E151: \\u884C\" + t.line + \": \\u6761\\u4EF6\\u884C\\u306F\\u6761\\u4EF6\\u306E\\u7D42\\u308F\\u308A\\u3067\\u6539\\u884C\\u3057\\u3088\\u3046\\u3002\\u300C\" + t.string + \"\\u300D\\u304C\\u7D9A\\u3044\\u3066\\u3044\\u308B\\u3002\");\n        }\n        return node;\n    };\n    // Array : name [ expression ]\n    Parser.prototype.parseArrayElement = function () {\n        var node = this.parseVariable();\n        if (node === null) {\n            return null;\n        }\n        node.type = NodeType_1.NodeType.NODE_ARRAY_ELEMENT;\n        // [\n        HLib_1.default.assert(this.mTokens[this.mPos].type === TokenType_1.default.TOKEN_INDEX_BEGIN, __filename + \":471\"); // getTermTypeで判定済み\n        this.mPos += 1;\n        // expression\n        var expression = this.parseExpression();\n        if (expression === null) {\n            return null;\n        }\n        node.child = expression;\n        // expressionが数値であれば、アドレス計算はここでやる\n        if (expression.type === NodeType_1.NodeType.NODE_NUMBER) {\n            node.number += expression.number;\n            node.child = null; // 子のExpressionを破棄\n        }\n        // ]\n        if (this.mTokens[this.mPos].type !== TokenType_1.default.TOKEN_INDEX_END) {\n            var t = this.mTokens[this.mPos];\n            throw new Error(\"E160: \\u884C\" + t.line + \": \\u540D\\u524D\\u3064\\u304D\\u30E1\\u30E2\\u30EA[\\u756A\\u53F7]\\u306E']'\\u306E\\u4EE3\\u308F\\u308A\\u306B'\" + t.string + \"'\\u304C\\u3042\\u308B\\u3002\\n\");\n        }\n        this.mPos += 1;\n        return node;\n    };\n    // Variable : name\n    Parser.prototype.parseVariable = function () {\n        var t = this.mTokens[this.mPos];\n        HLib_1.default.assert(t.type === TokenType_1.default.TOKEN_NAME, __filename + \":501\");\n        var node;\n        // 定数？変数？\n        var c = this.mConstMap[t.string];\n        if (typeof c !== 'undefined') {\n            node = new Node_1.default(NodeType_1.NodeType.NODE_NUMBER);\n            node.number = c;\n        }\n        else {\n            node = new Node_1.default(NodeType_1.NodeType.NODE_VARIABLE, t);\n        }\n        this.mPos += 1;\n        return node;\n    };\n    // Out : out\n    Parser.prototype.parseOut = function () {\n        var t = this.mTokens[this.mPos];\n        HLib_1.default.assert(t.type === TokenType_1.default.TOKEN_OUT, __filename + \":521\");\n        var node = new Node_1.default(NodeType_1.NodeType.NODE_OUT, t);\n        this.mPos += 1;\n        return node;\n    };\n    // Expression : expression +|-|*|/|<|>|≤|≥|≠|= expression\n    // 左結合の木になる。途中で回転が行われることがある。\n    // E170\n    Parser.prototype.parseExpression = function () {\n        // ボトムアップ構築して、左結合の木を作る。\n        // 最初の左ノードを生成\n        var left = this.parseTerm();\n        if (left === null) {\n            return null;\n        }\n        // 演算子がつながる限りループ\n        for (var t = this.mTokens[this.mPos]; t.type === TokenType_1.default.TOKEN_OPERATOR; t = this.mTokens[this.mPos]) {\n            // ノードを生成\n            // 演算子を設定\n            var node = Node_1.default.createExpression(t, t.operator || '', null, null);\n            this.mPos += 1;\n            // 連続して演算子なら親切にエラーを吐いてやる。\n            t = this.mTokens[this.mPos];\n            if ((t.type === TokenType_1.default.TOKEN_OPERATOR) && (t.operator !== '-')) { // -以外の演算子ならエラー\n                throw new Error(\"E170: \\u884C\" + t.line + \": \\u6F14\\u7B97\\u5B50\\u304C\\u9023\\u7D9A\\u3057\\u3066\\u3044\\u308B\\u3002==\\u3084++\\u3084--\\u306F\\u306A\\u3044\\u3002=>\\u3084=<\\u306F>=\\u3084<=\\u306E\\u9593\\u9055\\u3044\\u3060\\u308D\\u3046\\u3002\");\n            }\n            // 右の子を生成\n            var right = this.parseTerm();\n            if (right === null) {\n                return null;\n            }\n            // GT,GEなら左右交換して不等号の向きを逆に\n            if ((node.operator === '>') || (node.operator === '≥')) {\n                var tmp = left;\n                left = right;\n                right = tmp;\n                if (node.operator === '>') {\n                    node.operator = '<';\n                }\n                else {\n                    node.operator = '≤';\n                }\n            }\n            // 最適化。左右ノードが両方数値なら計算をここでやる\n            // 最適化。定数の使い勝手向上のために必須 TODO:a + 2 + 3がa+5にならないよねこれ\n            var preComputed = null;\n            if ((left.type === NodeType_1.NodeType.NODE_NUMBER) && (right.type === NodeType_1.NodeType.NODE_NUMBER)) {\n                var a = left.number;\n                var b = right.number;\n                if (node.operator === '+') {\n                    preComputed = a + b;\n                }\n                else if (node.operator === '-') {\n                    preComputed = a - b;\n                }\n                else if (node.operator === '*') {\n                    preComputed = a * b;\n                }\n                else if (node.operator === '/') {\n                    if (b === 0) {\n                        throw new Error(\"E171: \\u884C\" + t.line + \": 0\\u3067\\u5272\\u308A\\u7B97\\u3057\\u3066\\u3044\\u308B\\u3002\");\n                    }\n                    preComputed = Math.floor(a / b); // 整数化必須\n                }\n                else if (node.operator === '<') {\n                    preComputed = (a < b) ? 1 : 0;\n                }\n                else if (node.operator === '≤') {\n                    preComputed = (a <= b) ? 1 : 0;\n                }\n                else if (node.operator === '=') {\n                    preComputed = (a === b) ? 1 : 0;\n                }\n                else if (node.operator === '≠') {\n                    preComputed = (a !== b) ? 1 : 0;\n                }\n                else {\n                    throw new Error('BUG parseExpression #1'); // >と≥は上で置換されてなくなっている\n                }\n            }\n            if (preComputed !== null) { // 事前計算でノードをマージ\n                node.type = NodeType_1.NodeType.NODE_NUMBER;\n                node.number = preComputed;\n                left = null;\n                right = null;\n            }\n            else {\n                node.child = left;\n                left.brother = right;\n            }\n            // 現ノードを左の子として継続\n            left = node;\n        }\n        return left;\n    };\n    Parser.prototype.getTermType = function () {\n        var t = this.mTokens[this.mPos];\n        var r = NodeType_1.TermType.TERM_UNKNOWN;\n        if (t.type === TokenType_1.default.TOKEN_LEFT_BRACKET) {\n            r = NodeType_1.TermType.TERM_EXPRESSION;\n        }\n        else if (t.type === TokenType_1.default.TOKEN_NUMBER) {\n            r = NodeType_1.TermType.TERM_NUMBER;\n        }\n        else if (t.type === TokenType_1.default.TOKEN_NAME) {\n            t = this.mTokens[this.mPos + 1];\n            if (t.type === TokenType_1.default.TOKEN_LEFT_BRACKET) {\n                r = NodeType_1.TermType.TERM_FUNCTION;\n            }\n            else if (t.type === TokenType_1.default.TOKEN_INDEX_BEGIN) {\n                r = NodeType_1.TermType.TERM_ARRAY_ELEMENT;\n            }\n            else {\n                r = NodeType_1.TermType.TERM_VARIABLE;\n            }\n        }\n        else if (t.type === TokenType_1.default.TOKEN_OUT) {\n            r = NodeType_1.TermType.TERM_OUT;\n        }\n        return r;\n    };\n    // Term : [-] function|variable|out|array|number|(expression)\n    // E180\n    Parser.prototype.parseTerm = function () {\n        var t = this.mTokens[this.mPos];\n        var minus = false;\n        if (t.operator === '-') {\n            minus = true;\n            this.mPos += 1;\n        }\n        t = this.mTokens[this.mPos];\n        var termType = this.getTermType();\n        var node = null;\n        if (termType === NodeType_1.TermType.TERM_EXPRESSION) {\n            HLib_1.default.assert(t.type === TokenType_1.default.TOKEN_LEFT_BRACKET, __filename + \":651\");\n            this.mPos += 1;\n            node = this.parseExpression();\n            t = this.mTokens[this.mPos];\n            if (t.type !== TokenType_1.default.TOKEN_RIGHT_BRACKET) {\n                throw new Error(\"E180: \\u884C\" + t.line + \": ()\\u3067\\u56F2\\u307E\\u308C\\u305F\\u5F0F\\u304C\\u3042\\u308A\\u305D\\u3046\\u306A\\u306E\\u3060\\u304C\\u3001\\u7D42\\u308F\\u308A\\u306E')'\\u306E\\u4EE3\\u308F\\u308A\\u306B\\u300C\" + t.string + \"\\u300D\\u304C\\u3042\\u308B\\u3002\");\n            }\n            this.mPos += 1;\n        }\n        else if (termType === NodeType_1.TermType.TERM_NUMBER) {\n            node = Node_1.default.createNumber(t, t.number, null, null);\n            this.mPos += 1;\n        }\n        else if (termType === NodeType_1.TermType.TERM_FUNCTION) {\n            node = this.parseFunction();\n        }\n        else if (termType === NodeType_1.TermType.TERM_ARRAY_ELEMENT) {\n            node = this.parseArrayElement();\n        }\n        else if (termType === NodeType_1.TermType.TERM_VARIABLE) {\n            node = this.parseVariable();\n        }\n        else if (termType === NodeType_1.TermType.TERM_OUT) {\n            node = this.parseOut();\n        }\n        else {\n            throw new Error(\"E181: \\u884C\" + t.line + \": \\u3053\\u3053\\u306B\\u306F\\u3001()\\u3067\\u56F2\\u307E\\u308C\\u305F\\u5F0F\\u3001memory[]\\u3001\\u6570\\u3001\\u540D\\u524D\\u3064\\u304D\\u30E1\\u30E2\\u30EA\\u3001\\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u53C2\\u7167\\u3001\\u306E\\u3069\\u308C\\u304B\\u304C\\u3042\\u308B\\u306F\\u305A\\u306A\\u306E\\u3060\\u304C\\u3001\\u4EE3\\u308F\\u308A\\u306B\\u300C\" + t.string + \"\\u300D\\u304C\\u3042\\u308B\\u3002\");\n        }\n        if ((node !== null) && minus) {\n            if (node.type === NodeType_1.NodeType.NODE_NUMBER) { // この場で反転\n                node.number = -(node.number);\n            }\n            else { // 反転は後に伝える\n                node.negation = true;\n            }\n        }\n        return node;\n    };\n    // Function : name ( [ expression [ , expression ]* ] )\n    // E190\n    Parser.prototype.parseFunction = function () {\n        var t = this.mTokens[this.mPos];\n        HLib_1.default.assert(t.type === TokenType_1.default.TOKEN_NAME, __filename + \":688\");\n        var node = new Node_1.default(NodeType_1.NodeType.NODE_FUNCTION, t);\n        this.mPos += 1;\n        // '(''\n        t = this.mTokens[this.mPos];\n        HLib_1.default.assert(t.type === TokenType_1.default.TOKEN_LEFT_BRACKET, __filename + \":694\");\n        this.mPos += 1;\n        // 引数ありか、なしか\n        t = this.mTokens[this.mPos];\n        if (t.type !== TokenType_1.default.TOKEN_RIGHT_BRACKET) { // 括弧閉じないので引数あり\n            var exp = this.parseExpression();\n            if (exp === null) {\n                return null;\n            }\n            node.child = exp;\n            // 2個目以降はループで取る\n            var lastChild = exp;\n            for (;;) {\n                t = this.mTokens[this.mPos];\n                if (t.type !== TokenType_1.default.TOKEN_COMMA) {\n                    break;\n                }\n                this.mPos += 1;\n                exp = this.parseExpression();\n                if (exp === null) {\n                    return null;\n                }\n                lastChild.brother = exp;\n                lastChild = exp;\n            }\n        }\n        // ')'\n        if (t.type !== TokenType_1.default.TOKEN_RIGHT_BRACKET) {\n            throw new Error(\"E190: \\u884C\" + t.line + \": \\u90E8\\u5206\\u30D7\\u30ED\\u30B0\\u30E9\\u30E0\\u306E\\u5165\\u529B\\u304C')'\\u3067\\u7D42\\u308F\\u308B\\u306F\\u305A\\u3060\\u304C\\u3001\\u300C\" + t.string + \"\\u300D\\u304C\\u3042\\u308B\\u3002\");\n        }\n        this.mPos += 1;\n        return node;\n    };\n    return Parser;\n}());\nexports.default = Parser;\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/index.js\"))\n\n//# sourceURL=webpack:///./src/sunaba/Parser.ts?");

/***/ }),

/***/ "./src/sunaba/Sunaba.ts":
/*!******************************!*\
  !*** ./src/sunaba/Sunaba.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint\n    no-unused-vars: 0\n*/\n// MEMO: no-unused-vars: 0  2:8  error  'Locale' is defined but never used  no-unused-vars\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TokenType_1 = __importDefault(__webpack_require__(/*! ./TokenType */ \"./src/sunaba/TokenType.ts\"));\nvar Sunaba = /** @class */ (function () {\n    function Sunaba() {\n    }\n    // 識別子に含まれる文字か否か\n    Sunaba.isInName = function (c) {\n        var n = c.charCodeAt(0);\n        if (n >= 0x100) {\n            // マルチバイト文字は全てオーケー。半角相当品がある全角は置換済み。\n            return true;\n        }\n        var CHARS = '@$&?_\\'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        var i = CHARS.indexOf(c.charAt(0));\n        var f = i >= 0;\n        return f;\n    };\n    Sunaba.readKeyword = function (s, loc) {\n        var r;\n        if (s === 'while') {\n            r = TokenType_1.default.TOKEN_WHILE_PRE;\n        }\n        else if ((s === loc.whileWord0) || (s === loc.whileWord1)) {\n            r = (loc.whileAtHead) ? TokenType_1.default.TOKEN_WHILE_PRE : TokenType_1.default.TOKEN_WHILE_POST;\n        }\n        else if (s === 'if') {\n            r = TokenType_1.default.TOKEN_IF_PRE;\n        }\n        else if (s === loc.ifWord) {\n            r = (loc.ifAtHead) ? TokenType_1.default.TOKEN_IF_PRE : TokenType_1.default.TOKEN_IF_POST;\n        }\n        else if (s === 'def') {\n            r = TokenType_1.default.TOKEN_DEF_PRE;\n        }\n        else if (s === loc.defWord) {\n            r = (loc.defAtHead) ? TokenType_1.default.TOKEN_DEF_PRE : TokenType_1.default.TOKEN_DEF_POST;\n        }\n        else if ((s === 'const') || (s === loc.constWord)) {\n            r = TokenType_1.default.TOKEN_CONST;\n        }\n        else if ((s === 'out') || (s === loc.outWord)) {\n            r = TokenType_1.default.TOKEN_OUT;\n        }\n        else {\n            r = TokenType_1.default.TOKEN_UNKNOWN;\n        }\n        return r;\n    };\n    Sunaba.readInstruction = function (s) {\n        // 線形検索だけどコードが短い方を選んだ。ハッシュにしても良い。\n        var table = [\n            'i', 'add', 'sub', 'mul', 'div', 'lt', 'le', 'eq', 'ne',\n            'ld', 'st', 'fld', 'fst', 'j', 'bz', 'call', 'ret', 'pop',\n        ];\n        var n = table.length;\n        for (var i = 0; i < n; i += 1) {\n            if (s === table[i]) {\n                return table[i];\n            }\n        }\n        return '';\n    };\n    // マイナスも読めます(主に速度とデバグのために)\n    Sunaba.readNumber = function (code, begin, l) {\n        // 前提。lは0じゃない。空白は混ざっていない。\n        var r = 0;\n        var i = 0;\n        var minus = false;\n        if (code.substr(begin + i, 1) === '-') { // マイナスですね\n            i += 1;\n            minus = true;\n        }\n        var u0 = '0';\n        var u9 = '9';\n        var decimalExist = false;\n        while (i < l) {\n            r *= 10;\n            var c = code.substr(begin + i, 1);\n            if ((c >= u0) && (c <= u9)) {\n                r += c.charCodeAt(0) - u0.charCodeAt(0);\n                decimalExist = true;\n            }\n            else {\n                break;\n            }\n            i += 1;\n        }\n        if (decimalExist) { // 数字が存在している\n            r = (minus) ? -r : r;\n        }\n        else {\n            r = NaN; // 数字がなかった。nullを返す。\n        }\n        return r;\n    };\n    Sunaba.MAX_ABS_NUMBER = 2147483647; // 2^31 - 1\n    // Sunaba.Locale\n    Sunaba.locales = {\n        japanese: {\n            whileWord0: 'なかぎり',\n            whileWord1: 'な限り',\n            whileAtHead: false,\n            ifWord: 'なら',\n            ifAtHead: false,\n            defWord: 'とは',\n            defAtHead: false,\n            constWord: '定数',\n            outWord: '出力',\n            memoryWord: 'メモリ',\n            argDelimiter: '、',\n        },\n    };\n    return Sunaba;\n}());\nexports.default = Sunaba;\n\n\n//# sourceURL=webpack:///./src/sunaba/Sunaba.ts?");

/***/ }),

/***/ "./src/sunaba/Token.ts":
/*!*****************************!*\
  !*** ./src/sunaba/Token.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TokenType_1 = __importDefault(__webpack_require__(/*! ./TokenType */ \"./src/sunaba/TokenType.ts\"));\nvar Token = /** @class */ (function () {\n    function Token(type, line, string, number) {\n        if (string === void 0) { string = ''; }\n        if (number === void 0) { number = undefined; }\n        this.type = type;\n        this.line = line;\n        this.string = string;\n        if (number !== undefined) {\n            this.number = number;\n        }\n    }\n    Token.createcOperater = function (line, string) {\n        var token = new Token(TokenType_1.default.TOKEN_OPERATOR, line, string);\n        token.operator = string;\n        return token;\n    };\n    return Token;\n}());\nexports.default = Token;\n\n\n//# sourceURL=webpack:///./src/sunaba/Token.ts?");

/***/ }),

/***/ "./src/sunaba/TokenType.ts":
/*!*********************************!*\
  !*** ./src/sunaba/TokenType.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint no-unused-vars: 0 */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TokenType;\n(function (TokenType) {\n    // 特定の文字列と対応する種類\n    TokenType[TokenType[\"TOKEN_WHILE_PRE\"] = 0] = \"TOKEN_WHILE_PRE\";\n    TokenType[TokenType[\"TOKEN_WHILE_POST\"] = 1] = \"TOKEN_WHILE_POST\";\n    TokenType[TokenType[\"TOKEN_IF_PRE\"] = 2] = \"TOKEN_IF_PRE\";\n    TokenType[TokenType[\"TOKEN_IF_POST\"] = 3] = \"TOKEN_IF_POST\";\n    TokenType[TokenType[\"TOKEN_DEF_PRE\"] = 4] = \"TOKEN_DEF_PRE\";\n    TokenType[TokenType[\"TOKEN_DEF_POST\"] = 5] = \"TOKEN_DEF_POST\";\n    TokenType[TokenType[\"TOKEN_CONST\"] = 6] = \"TOKEN_CONST\";\n    TokenType[TokenType[\"TOKEN_INCLUDE\"] = 7] = \"TOKEN_INCLUDE\";\n    TokenType[TokenType[\"TOKEN_LEFT_BRACKET\"] = 8] = \"TOKEN_LEFT_BRACKET\";\n    TokenType[TokenType[\"TOKEN_RIGHT_BRACKET\"] = 9] = \"TOKEN_RIGHT_BRACKET\";\n    TokenType[TokenType[\"TOKEN_COMMA\"] = 10] = \"TOKEN_COMMA\";\n    TokenType[TokenType[\"TOKEN_INDEX_BEGIN\"] = 11] = \"TOKEN_INDEX_BEGIN\";\n    TokenType[TokenType[\"TOKEN_INDEX_END\"] = 12] = \"TOKEN_INDEX_END\";\n    TokenType[TokenType[\"TOKEN_SUBSTITUTION\"] = 13] = \"TOKEN_SUBSTITUTION\";\n    TokenType[TokenType[\"TOKEN_OUT\"] = 14] = \"TOKEN_OUT\";\n    // 実際の内容が様々であるような種類\n    TokenType[TokenType[\"TOKEN_NAME\"] = 15] = \"TOKEN_NAME\";\n    TokenType[TokenType[\"TOKEN_STRING_LITERAL\"] = 16] = \"TOKEN_STRING_LITERAL\";\n    TokenType[TokenType[\"TOKEN_NUMBER\"] = 17] = \"TOKEN_NUMBER\";\n    TokenType[TokenType[\"TOKEN_OPERATOR\"] = 18] = \"TOKEN_OPERATOR\";\n    TokenType[TokenType[\"TOKEN_STATEMENT_END\"] = 19] = \"TOKEN_STATEMENT_END\";\n    TokenType[TokenType[\"TOKEN_BLOCK_BEGIN\"] = 20] = \"TOKEN_BLOCK_BEGIN\";\n    TokenType[TokenType[\"TOKEN_BLOCK_END\"] = 21] = \"TOKEN_BLOCK_END\";\n    TokenType[TokenType[\"TOKEN_LINE_BEGIN\"] = 22] = \"TOKEN_LINE_BEGIN\";\n    TokenType[TokenType[\"TOKEN_END\"] = 23] = \"TOKEN_END\";\n    TokenType[TokenType[\"TOKEN_UNKNOWN\"] = 99] = \"TOKEN_UNKNOWN\";\n    TokenType[TokenType[\"TOKEN_LARGE_NUMBER\"] = 100] = \"TOKEN_LARGE_NUMBER\"; // エラーメッセージ用\n})(TokenType || (TokenType = {}));\nexports.default = TokenType;\n\n\n//# sourceURL=webpack:///./src/sunaba/TokenType.ts?");

/***/ }),

/***/ "./src/sunaba/VmCommand.ts":
/*!*********************************!*\
  !*** ./src/sunaba/VmCommand.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar VmCommand = /** @class */ (function () {\n    function VmCommand(label, name, imm, comment) {\n        if (imm === void 0) { imm = 0; }\n        if (comment === void 0) { comment = ''; }\n        this.label = '';\n        this.imm = 0;\n        this.comment = '';\n        this.label = label;\n        this.name = name;\n        this.imm = imm;\n        this.comment = comment;\n    }\n    return VmCommand;\n}());\nexports.default = VmCommand;\n\n\n//# sourceURL=webpack:///./src/sunaba/VmCommand.ts?");

/***/ })

/******/ });