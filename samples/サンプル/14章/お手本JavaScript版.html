<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"><title>お手本javascript版</title>
<style>
<!--
td { width: 10px; height: 10px; }
body { background-color: black; }
.white { background-color: white; }
.black { background-color: black; }
.red { background-color: red; }
-->
</style>
<script>
//Sunabaのお手本に極力合わせるため, javascriptとしては非常に不自然になっているが, 意図的なので叩かないでほしい
//IE8とchromeしか試してない。
メモリ = new Array()
画面 = new Array() //マス目単位の12×20の配列。ここに色をつっこんで, 後でテーブルの背景色を変えて描画する
縦 = 1
横 = 5
回転 = 0
種類 = 0
落下カウント = 0
左 = 0
右 = 0
上 = 0
if (window.addEventLisnter){ //標準
   window.addEventListener("load", 準備, true) //起動する場所を設定
   window.addEventListener("keydown", キー取得, true) //キーが押されたらやることを設定
}else{ //IE8とかの古いブラウザ用
   window.onload = 準備
   document.onkeydown = キー取得
}
function 準備(){
   //メモリを999番まで0に。本来javascriptなら「メモリ」なんてものを作る必要はないが, Sunabaに近づけるためにこうしておく
   var 回数 = 0
   while (回数 < 1000){
      メモリ[回数] = 0
      回数 = 回数 + 1
   }
   //背景を真っ黒に
   回数 = 0
   while (回数 < (12 * 20)){
      画面[回数] = 0
      回数 = 回数 + 1
   }
   //テーブルの中身を作って画面を初期化する
   var screen = document.getElementById("画面")
   var y = 0
   while (y < 20){
      var line = document.createElement("tr")
      var x = 0
      while (x < 12){
         var cell = document.createElement("td")
         cell.setAttribute("class", "black")
         line.appendChild(cell)
         x = x + 1
      }
      screen.appendChild(line)
      y = y + 1
   }
   //ここがSunabaのプログラム開始に相当
   パターンを前もって作っておく()
   壁と底を描く() 
   window.setInterval(無限繰り返し範囲, 17) //「無限繰り返し」が1/60秒(17ms)ごとに参照されるように設定する
}
function キー取得(ev){
   if (ev == null){ //IE8用
      ev = window.event
   }
   //keyCodeも, その数とキーの対応もブラウザ依存。そのうち統一ルールができたらそれに合わせて書き直すべき。
   if (ev.keyCode == 37){
      左 = 1
   }
   if (ev.keyCode == 38){
      上 = 1
   }
   if (ev.keyCode == 39){
      右 = 1
   }
}
function 画面を更新する(){ //背景色を変えて回る
   var screen = document.getElementById("画面")
   var y = 0
   var line = screen.firstChild
   while (y < 20){
      var x = 0
      var cell = line.firstChild
      while (x < 12){
         var color = 画面[(y * 12) + x]
         var s = ""
         if (color == 0){
            s = "black"
         }else if (color == 999999){
            s = "white"
         }else if (color == 990000){
            s = "red"
         }
         cell.setAttribute("class", s)
         x = x + 1
         cell = cell.nextSibling
      }
      y = y + 1
      line = line.nextSibling
   }
}
//ここまではjavascript特有の事情が多いが, 
//以下はSunaba版のお手本とだいたい同じにしてある。
function 無限繰り返し範囲(){
   //移動量。Sunabaと違って, 押された瞬間に右, 左, 上を1にしてくれる仕組みがある。
   var 横移動量 = 右 - 左
   var 縦移動量 = 0
   var 回転量 = 上
   //使い終わったので0にしておく。押された時に「キー取得」が使われて1になる。
   左 = 0
   右 = 0
   上 = 0
   //落ちる
   落下カウント = 落下カウント + 1
   if (落下カウント == 10){
      縦移動量 = 1
      落下カウント  = 0
   }
   //移動を反映
   縦 = 縦 + 縦移動量
   横 = 横 + 横移動量
   回転 = 回転 + 回転量
   if (重なってるか(縦, 横, 回転, 種類)){
      //戻す
      縦 = 縦 - 縦移動量
      横 = 横 - 横移動量
      回転 = 回転 - 回転量
      if ((縦移動量 > 0) && (横移動量 == 0)){
         積もらせて列を消す(縦, 横, 回転, 種類)
         縦 = 1
         横 = 5
         回転 = 0
         種類 = 種類 + 1
         if (種類 > 6){
            種類 = 0
         }
      }
   }
   四角を動かす(縦, 横, 回転, 種類)
}
function パターンを前もって作っておく(){
   メモリに6つ覚えさせる(500, 0, -1, 0, 1, 0, 2) //形0
   メモリに6つ覚えさせる(506, -1, -1, 0, -1, 0, 1) //形1
   メモリに6つ覚えさせる(512, 0, -1, -1, 0, 0, 1) //形2
   メモリに6つ覚えさせる(518, 0, -1, -1, 1, 0, 1) //形3
   メモリに6つ覚えさせる(524, 0, -1, 1, 0, 1, 1) //形4
   メモリに6つ覚えさせる(530, 0, 1, 1, 0, 1, 1) //形5
   メモリに6つ覚えさせる(536, 0, 1, 1, -1, 1, 0) //形6
}
function メモリに6つ覚えさせる(開始番号, 数0, 数1, 数2, 数3, 数4, 数5){
   メモリ[開始番号 + 0] = 数0
   メモリ[開始番号 + 1] = 数1
   メモリ[開始番号 + 2] = 数2
   メモリ[開始番号 + 3] = 数3
   メモリ[開始番号 + 4] = 数4
   メモリ[開始番号 + 5] = 数5
}
function マス目位置を計算する(縦, 横, 回転, 種類){
   メモリ[0] = 縦
   メモリ[1] = 横
   var 開始番号 = 500 + (種類 * 6)
   var 回数 = 0
   while (回数 < 3){
      var 相対縦 = メモリ[開始番号 + (回数 * 2) + 0]
      var 相対横 = メモリ[開始番号 + (回数 * 2) + 1]
      var 回転回数 = 0
      while (回転回数 < 回転){
         //入れ替え
         var 入れ替え用 = 相対縦
         相対縦 = 相対横
	 相対横 = 入れ替え用
	 //プラスマイナスひっくり返す
	 相対横 = -相対横
	 回転回数 = 回転回数 + 1
      }
      メモリ[2 + (回数 * 2)] = 縦 + 相対縦
      メモリ[3 + (回数 * 2)] = 横 + 相対横
      回数 = 回数 + 1
   }
}
function 重なってるか(縦, 横, 回転, 種類){
   マス目位置を計算する(縦, 横, 回転, 種類)
   return (メモリ[100 + (メモリ[0] * 12) + メモリ[1]] == 1) ||
      (メモリ[100 + (メモリ[2] * 12) + メモリ[3]] == 1) ||
      (メモリ[100 + (メモリ[4] * 12) + メモリ[5]] == 1) ||
      (メモリ[100 + (メモリ[6] * 12) + メモリ[7]] == 1)
}
function 積もらせて列を消す(縦, 横, 回転, 種類){
   マス目位置を計算する(縦, 横, 回転, 種類)
   積もる(メモリ[0], メモリ[1])
   積もる(メモリ[2], メモリ[3])
   積もる(メモリ[4], メモリ[5])
   積もる(メモリ[6], メモリ[7])
   列を消す()
}
function 四角を動かす(縦, 横, 回転, 種類){
   マス目位置を計算する(縦, 横, 回転, 種類)
   四角(メモリ[0], メモリ[1], 990000) //赤
   四角(メモリ[2], メモリ[3], 990000) //赤
   四角(メモリ[4], メモリ[5], 990000) //赤
   四角(メモリ[6], メモリ[7], 990000) //赤
   画面を更新する()
   四角(メモリ[0], メモリ[1], 0) //消す
   四角(メモリ[2], メモリ[3], 0) //消す
   四角(メモリ[4], メモリ[5], 0) //消す
   四角(メモリ[6], メモリ[7], 0) //消す
}
function 積もる(縦, 横){
   メモリ[100 + (縦 * 12) + 横] = 1
   四角(縦, 横, 999999)
}
function 壁と底を描く(){
   壁を描く()
   底を描く()
}
function 壁を描く(){
   var 回数 = 0
   while (回数 < 20){
      積もる(回数, 0) //左
      積もる(回数, 11) //右
      回数 = 回数 + 1
   }
}
function 底を描く(){
   var 回数 = 0
   while (回数 < 10){
      積もる(19, 1 + 回数)
      回数 = 回数 + 1
   }
}
function 四角(縦, 横, 色){
   //実際に絵を描くのは別のところになる
   画面[(縦 * 12) + 横] = 色
}
function 列を消す(){
   var 縦 = 0
   while (縦 < 19){
      var 消えるか = true
      var 横 = 1
      while (横 <= 10){
         消えるか = 消えるか && (メモリ[100 + (縦 * 12) + 横] == 1)
         横 = 横 + 1
      }
      if (消えるか){
         //積もったと覚えているメモリを0にする
         var 横 = 1
         while (横 < 10){
            メモリ[100 + (縦 * 12) + 横] = 0 //メモリを0に
            四角(縦, 横, 0) //黒で塗りつぶす
            横 = 横 + 1
         }
         ずらす(縦)
      }
      縦 = 縦 + 1
   }
}
function ずらす(消える列の縦){
   var 縦 = 消える列の縦 - 1
   while (縦 >= 0){
      var 横 = 1
      while (横 <= 10){
         if (メモリ[100 + (縦 * 12) + 横] == 1){
            メモリ[100 + (縦 * 12) + 横] = 0 //消す
            四角(縦, 横, 0) //黒く塗る
            積もる(縦 + 1, 横)
         }
         横 = 横 + 1
      }
      縦 = 縦 - 1
   }
}
</script>
</head>
<body>
	<table id="画面"></table>
</body>
</html>
